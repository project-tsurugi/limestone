
# limestone LOG-2 実装 (案1) の選択に関わる対比項目

## この文書は何か

* [LOG-2 設計詳細](./log2-implementation-detail.md) から、実装上の選択肢候補を抽出したもの。
    * 各選択肢には固有の識別コードを振った。
    * 対立点に対しての考察を記述した。

<!-- 用語の統一
　吸い上げ　←　吸出し
 -->


## ログデータを VB に渡すところ

* コントロールフローの向き 候補
    * 監視型 (ログディレクトリを監視して pWAL ファイルへの追記分を VB に吸い上げる)
        * (SYNC-WP) 別プロセス
            * (SYNC-WP-NO) inotify/kqueue で変更が検出されたファイルを open, seek, read, close
            * (SYNC-WP-NR) inotify/kqueue で変更が検出されたファイルを read。各pWALファイルは開きっぱなし
            * (SYNC-WP-LR) wait しつつファイル無限 read loop。各pWALファイルは開きっぱなし
        * (SYNC-WT) 別スレッド
            * (SYNC-WT-NO) inotify/kqueue で変更が検出されたファイルを open, seek, read, close
            * (SYNC-WT-NR) inotify/kqueue で変更が検出されたファイルを read。各pWALファイルは開きっぱなし
            * (SYNC-WT-LR) wait しつつファイル無限 read loop。各pWALファイルは開きっぱなし
    * 通知型 (`log_channel` がログデータを受け取るたびに VB 吸い上げ機構へ通知)
        * (SYNC-LN) `log_channel::write_entry` 等が pWAL への書き込みの直後に、吸い上げスレッドに通知。吸い上げスレッドは、通知ドリブンでそのファイルを読んで吸い上げる
            * (コメント) スレッドを分けているのは、素早く返るため
            * (SYNC-LN-NO) 通知されたファイルを open, seek, read, close
            * (SYNC-LN-NR) 通知されたファイルを read。各pWALファイルは開きっぱなし
    * push 型 (`log_channel` がログデータを VB へ投入)
        * (SYNC-LP) `log_channel::write_entry` 等が pWAL への書き込みの直後に、追加されたログエントリを VB に格納する (データは pWALファイルを経由しない)
            * (SYNC-LP-C) enQ を別スレッド
                * (コメント) スレッドを分けているのは、VB へ格納する処理を待たずに素早く呼び出しもとに戻るため
                * (コメント) 処理が戻った先でデータ(特に payload)を破壊するかもしれないので、コピーする必要がある。そのためスレッド間でデータ移動のコストが発生する。コピーするくらいならさっさと PQ に突っ込んでもあまり変わらないのでは?
                    * (コメント) enQ コスト次第か
            * (SYNC-LP-S) enQ も直列。VB に格納してから (`log_channel::write_entry` 等より) 戻る

監視型 vs 通知型 vs push型 (LOG-0 からの負荷増分の比較)
* 監視型・通知型の場合、LOG-0 に比べて余計なファイル読み出しが起こる (ただ、ディスクキャッシュに載っているはず)
* push 型の場合、LOG-0 に比べて余計なメモリ操作と、VB への enQ で、状態(フラッシュタイミング)によっては余計な待ちが発生する可能性がある

(\*-NO) vs (\*-NR) vs (\*-LR)
* NR では、ファイルデスクリプタを監視対象数ぶん消費(利用)する。一番 naive だと log ディレクトリにある pWAL ファイル総数 (閉じられているファイルも入る)
    * 工夫の余地はある。SYNC-WP/WT ではログファイルの開閉も監視して監視対象を減らす、SYNC-LN ではアクティブな pWAL ファイルがわかる、等
* LR では、ファイルデスクリプタを利用 log_channel数 ぶん消費(利用)する。
    * 基本的に log_channel ぶんのスレッドにて並列に処理する
* NO では、ファイルデスクリプタを並列吸い上げ数ぶん、消費(利用)する。負荷が低い時は 0 だが、高並列時には LR と同じになる。
    * 吸い上げの同時並列数に制約を設けることでファイルデスクリプタの使用数に上限を設定できる。
* NO では、NR,LR に比べてファイル開閉のオーバーヘッドが発生する。また、(想像だが) ディスクキャッシュ的にも不利ではないか?
* (総括) 仮に、ファイルデスクリプタの数が問題にならないということであれば、 NO を選ぶ理由はない。


## バージョンバッファ (VB)

バージョンバッファに格納されるデータの寿命は多くの場合には、短い。はず。（要確認）  
だが LTX がトランザクション張りっぱなしにするとかで、とんでもなく長くなる可能性がある。  
また、大量にため込まれた場合、次の読み出しで一気に空近くまで読みだされる、はず。（要確認）

* バージョンバッファの実装 候補
    * (VB-R) RocksDB に PQ 用の Column Family (例えば "verbufCF") を作り利用する
    * (VB-S) SSTables で自前実装する
        * (コメント) わざわざ自前実装するなら SSTable 構造にする意味がない
    * (VB-M) メモリ中に 並列アクセス可能な multi-producer-single-consumer priority queue を持つ
        * (VB-M-O) 全てメモリに持つ。メモリが足りなくなったら破滅 (← たぶん許されない)
        * ある程度の量メモリに持つが、多くなってきてメモリが足りなくなったら、どこかに退避する。VB 読み出し時には、退避先も見る(消費する)ようにする
            * (VB-M-F) 自前実装: ファイルに書き出し、管理する
                * (コメント) メモリがいっぱいになるたびにソート済みデータ列を書き出す
                * (コメント) バックアップ系要求でも書き出す
            * (VB-M-R) RocksDB (verbufSwapoutCF) にゆだねる
        * (上記選択に加えて(直積で)、PQ の実装方法、ライブラリ選択、の組み合わせがある)

(VB-R) コメント
* RocksDB にするデメリット
    * RocksDB などの SSTable は short lifetime オブジェクトを格納するのに向いていない。
        * さらに、 RocksDB の挙動の話をすると、作ったエントリをすぐ消しても、墓石を置き、L0 SSTable ファイルまではそのまま(エントリと墓石が)書き出されてしまう。L1 SSTable にするときにコンパクションで対消滅する。
          * ファイルに書く前に対消滅してくれれば、圧倒的に I/O量が減るはずなのだが、そうならない。
* RocksDB に格納する利点
    * まとめてバックアップやチェックポイントができる
    * わざわざデータ構造やアルゴリズムを実装しなくてもよい
    * VB から SSDS へのデータ移動が Atomic にできる

(VB-M-F) コメント
* std::string のように、動的に割り当てたバッファへのポインタを持つオブジェクトは、オブジェクトのサイズは固定であっても使用するメモリはより大きくなる。
    * 中身の `size()` 等を足し合わせて使用メモリ量の近似値をとる必要がある
    * むしろ、オブジェクトサイズ自体が可変ってことがあるのだろうか? スタックにアロケートするのに困らない? あってもきわめて珍しい部類だと思う。
* 3GB のログエントリとかをどしどし書かれるような状況では、1エントリ書くたびに退避しなくてはならなくなってしまう。
    * 今、データベースエンジンのどこかに 1KB のサイズ制約があるので、巨大データが limestone に渡ってくることはないはずだが。
* なんとかしてメモリ使用量が推定できたら、閾値を設定して、それを超えたらファイルに書き出すようにする。
* ひっ迫していなくても、バックアップ要求時には、強制的にファイルに吐くことにする。そうしないと PITR 等を永続化できない。
    * (safe snapshot 以後なので SSDS には格納できない、pWAL ファイルはいずれ移動されてしまう)
* VB が肥大化しているときに PITR 要求が来ると、処理に大きく時間がかかる

(VB-S)
* VB-R, VB-M-\* と比較して、特に有利な点がなさそうなので候補から除外する

### Safe Snapshot データストア (Safe Snapshot Datastore / SSDS)

* SSDS をどう実現するか
    * (SSDS-R) RocksDB を使用
        * チューニングパラメータでいろいろ選択の余地があるぐらい?
            * (掛ける) CF の設計, key の構成
    * (SSDS-M) 永続化可能で堅牢な KVS を手で実装

(SSDS-R) vs (SSDS-M)
* LOG-2 に要求される機能の多く(snapshot, backup, pitr), 非機能 (書き込み性能) の要件を実装するにあたり、RocksDB は多くの機能, 非機能 を提供しており、これを使用することにより、大幅な実装工数削減が見込める。
