# Epoch Fileに関する修正

## 問題点

現在のEpochファイルには、以下の2つの問題がある。

1. ローテーション時にEpochファイルもローテーションされるが、ローテーションされたEpochファイルを削除する機能が存在しないため、ファイルが増え続ける。
2. ローテーションを行わないと、Epochファイルのサイズが単純に増え続けるので、以下の問題が生じる。
   * ディスク容量を無駄に消費する。
   * ファイルサイズの巨大化による性能劣化
   * ファイルサイズの制限により動かんくなる(おそらく現実的には発生しなし)
  

## 修正方針


### ローテーションされたEpochファイルを増やさないための修正

* コンパクション時には、Epochファイルのローテーションが不要にもかかわらずローテーションを行っているので、これをやめる。
* Epochの追記時に、Epochファイルのサイズが一定サイズを超えた場合に、Epochファイルの切り詰めを行う。
  * 以下のロジックでEpochファイルの着る詰めを行う
    * テンポラリファイルを作成する。
    * テンポラリファイルにEpochを書き込む
    * テンポラリファイルと、Epochファイルをrename2を使用してアトミックに入れ替える。
    * テンポラリファイル(=もとのEpochファイル)を削除する。
  * この操作は、クリティカルセクション内で行い、他のEpocファイルに関する操作が干渉しないようにする。


### ローテーションされたEpochファイルを削除するための修正

* コンパクション時にEpochファイルのローテーションをやめたので、Epochファイルのローテーションが行われるのは、
  バックアップのためのローテーション時のみになる。
* ローテーションされたEpochファイルはバックアップ終了後に削除可能だが、 現状バックアップ終了を検知する手段がない。
* 現段階ではローテーションされたEpochファイルを削除する機能は実装せず、バックアップ後のクリーニング機能実装時に併せて実装する。
  * バックアップ時のクリーニング機能
    * バックアップ時に、またはバックアップ語に当該バックアップがあれば不要になるローテーション済みファイルを削除する機能。

## 現状のEpochの仕様

### 起動時

* epoch_id_type dblog_scan::last_durable_epoch_in_dir()で、epochを決定している。
* この関数の処理内容
  * main_epoch_file: ローテーションしていないepochファイルが存在しない場合はエラー(=>異常終了)
    * ログディレクトリが空の場合は異常終了していはいけない。このようなケースでは、関数が呼ばれる前にディレクトリが初期化されEpochファイルが存在すろちう前提なのだろう。
  * main_epoch_fileからepochが取り出し、その値を返す。
  * main_pepch_fileからepochを取り出せなかった場合、全てのローテーション済みのepoch_fileから、epochを取り出し、最大のepochを適用する。
  * epochファイルからpeochの取り出しは、last_durable_epoch()を使用している。
* last_durable_epoch()の処理内容。
  * epochファイルを順に呼んでいき、最後のエントリのEpoch IDを返す。
  * marker_durable以外のエントリがある場合エラー
  * エントリがない場合は、空のEpoch IDを返す。
    * => 戻り値は、Optional

### Epcohファイル更新時

datastore::update_min_epoch_id()で、
epoch_idを決定して、epochファイルにエントリを追加している



### Epochファイルのローテーション

* datastore::rotate_epoch_file()で行われている。
  * 現行のEpochファイルをリネームして、ローテンション済みファイルにする。
  * リネームしたファイルをdatastoreが管理するファイルのリストに追加する。
  * 新しいEpochファイルを作成する。
  
### 現状のEpochの問題点と対応方針
* ローテーション時のリネームから新規Epochファイルの作成までの間にプロセスが落ちると、Epochファイルが存在しない状態になる。
  * 新規Epochファイルの作成失敗時も同じ状態になる。
  * この状態で次回起動時に、Epochファイルが存在しないことが理由で起動に失敗し、手作業でEpochファイルを復旧しない限り、起動しなくなる。
* 単に起動時にEpochファイルが存在シない場合は、ローテーションされたEpochファイルを参照するようにすればよさそうだが、Epochファイルの存在有無を、正しいログディレクトリが存在するかの確認のためにも使用しているので、単純な方法ではNG。

* 対応方針1
  * 一時的にEpochファイルが存在しない状態を許容する。
  * 起動時にEpochファイルが存在しない場合も、Epochファイルが空の場合と同様に、ローテションされたファイルからDurabe Epochを取得する。
  * Epochファイルの存在を、正しいログディレクトリが指定されたことの確認に使用せず、別の方法で確認する。
    * マニフェストファイルをこの用途に使用する。
    * ついでにマニフェストファイルにFlockをかけて、道立ログディレクトリを使用したTsurugiの二重起動防止や、Tsurugi起動中にtglogutilでログを修正することの防止にも使用する。
  

## Epochファイル更新時のepoch_idの決定ロジック

datastore::update_min_epoch_id()の処理だが、コードを読んでも
何をしているのかわからないので、関連する変数がどのように扱われているのかを調べる。

関連する変数とは

* datastore::update_min_epoch_id()のローカル変数
  * upper_limit
    * よくわからない
  * max_finished_epoch
    * よくわからない
  * old_epoch_id
    * 関数実行中のある瞬間のepoch_id_recorded_の値
  * to_be_epoch
    * Epochファイルに書き込むべきepoch_id、ただしこの値がold_epoch_id未満の場合は、Epochファイルに書き込まない。
    * 永続化処理の後、upper_limitが代入され処理が行われる~~が、何をしているのか分からない。~~
      * 特定の条件を満たすときにinformed_epoch_を、upper_limitに設定し、persistent_callback_を呼び出している。
      * uppper_limitの値をto_be_epochに設定しているのは、informed_epoch_に設定すべき値という意味であり、前の方の処理では、永続化する値という意味だと思われる。2つの値は必ずしも一致しない。
  * old_epoch_id
    * 関数実行中のある瞬間のepoch_id_informed_の値

* datasotreクラスのフィールド
  * epoch_id_switched_
    * 最後のdatastore::switch_epoch()呼び出しの引数で指定されたepoch_idの値
    * 起動時には、datastore::create_snapshot()で値が設定される。
      * snapshot作成時に戻り値として返されるepoch_idを設定する。
      * 具体的にどのような値が設定されるかは未調査。
  * epoch_id_recorded_
    * epochファイルに書き込んだ値？
  * epoch_id_informed_
    * persistent_callback_で通知したepoch_idの値

* log_channelクラスのフィールド
  * current_epoch_id_
    * セッション開始時に、epoch_id_switched_の値がセットされる。
    * セッション修了時にクリアされる(UINT64_MAX)
  * latest_ession_epoch_id_
    * セッション開始時に、epoch_id_switched_の値がセットされる。
    * current_epoch_id_と異なりセッションが終了しても保持される




