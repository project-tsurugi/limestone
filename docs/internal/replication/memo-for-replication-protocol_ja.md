# レプリケーション最小構成の通信プロトコルに関するメモ

[レプリケーション最小構成の通信プロトコル](https://nautilus-technologies.app.box.com/file/1798577910013)に関するメモです。


### 共通データ構造

ackとerrorにどのメッセージに対するAckなのかの情報がないのは、
必ずackが返るプロトコルだからか。


### TCP ソケットのステート

これは、通信プロトコル？、マスタとレプリカがソケットチャネルを管理するステータス？

=> ステートマシンのステートのようだ。
=> 実装上、サーバ側でう少しステータスが増えるかも。
=> 通信プロトコルで流れるステータスならこれでOK


### プロトコル：ログエントリ送付

複数のエントリをまとめて送ることを想定しているようだ。
その想定をしていなかった。


### プロトコル：ログチャネル書き出し

fsyncの呼び出したときにAckを返すのか、
fsyncが終了したときにackを返すのか => たぶんこっち




### プロトコルに関する確認事項

以下の理解であっていますか。

**共通データ構造**

* Ackに、どのメッセージに対するAckなのかの情報がないのは、Masterがメッセージを送信、レプリカがAckを返すを繰り返すことを想定しているため。

**プロトコル：ログエントリ送付**

* 操作フラグは、TCPのSYNやFINフラグと類似したものと理解
* `log_channel::begin_session`や、`log_channel::end_session`を一つのメッセージとして送らず、`log_channel::add_entry`等のデータと合わせて送ることが可能。
* エントリリストの要素数が0で、`LOG_OPERATION_SESSION_BEGIN`だけのメッセージを送ることもOK



**その他**

* 到達保証と順序保証があるTCP上で使用することを想定している。RDMAなど別の通信手段を用いる場合は、メッセージ定義を見直すことで対応する。



### プロトコルに関する質問

* プロトコル上は、ログエントリをまとめて送ることが可能ですが、最小構成の実装では、`log_channel::add_entry`の呼び出しごとに、ログエントリ送付のメッセージを送ろうと思いますが良いでしょうか。
* 上に関連して、ログエントリ送付の都度Ackを待つのは性能面で問題があるので、Ackを返す(待つ)のは、`LOG_OPERATION_SESSION_END`または`LOG_OPERATION_FLUSH`のフラグが立っているときだけに仕様と思います。良いでしょうか。
  * これにより、Ackと待つことにより遅延が避けられます。また、適切にTCP_NODELAYの設定を行うことにより、小さなTCPパケットを多数送るような状況を回避できます。
* `LOG_OPERATION_FLUSH`、`LOG_OPERATION_FLUSH`のフラグが立っていた時、レプリカ側はどう動作すべきでしょうか。
  * メッセージの受信完了したら、ACKを返す。
    * メッセージがレプリカに届いたことが保証される。
    * レプリカが正常に動作していれば、データが保証される。
  * メッセージをストレージに書き込んだら(当該永続化セッションの最後のWriteシステムコールが終了したら)、ACKを返す。
    * レプリカのプロセスに障害が起きても、OSが正常で、H/W障害がなければデータが保証される。
  * メッセージをストレージに書き込んだ後、fsyncが終了したらAckを返す。
    * H/W障害がなければデータが保証あｓれる。
* 上の質問と、ほぼ同義ですが、`LOG_OPERATION_FLUSH`、`LOG_OPERATION_FLUSH`はどのような使い分けを想定していますか。
  * 最小構成の実装では、`log_channel::end`が呼ばれたときに、この二つのフラグを立てたメッセージを送って、ACKが返るのを待つようにするつもりです。    


