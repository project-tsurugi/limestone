# レプリケーション機能の実装方針

## 本土ドキュメントについて

[レプリケーションの最小構成](https://nautilus-technologies.app.box.com/file/1794091239958)
に基づき、実装方針を記述したものです。本ドキュメントでは、「レプリケーションの最小構成」を単に「最小構成」と記述することがある。

## 基本方針

### マスター

Limestone以外は、基本的に既存のTurugiのモジュールをそのまま使用し、Limestone単独でレプリケーションに対応し、マスターとして動作する。

* 短期間で最小構成のレプリケーションを実現するために、Limestone以外のモジュールとの依存を避けたいのが最大の理由
* このため、本来は別の方法をとるべき、ところで前提的な対応をすることがある。
  * 例えば、レプリカとの通信パラメータを、tsurugi.iniでなく環境変数などで取得するなど。


### レプリカ

limestoneの独立コマンドとして実装する。

* 既存のDatastore, 通信関連のクラス、mainメソッドを持ち、前述の二つのモジュールをコントロールするモジュールから構成する。

* レプリケーションの最小構成では終了手段を用意しない。終了したいときは、プロセスを終了させるシグナルを送信して終了する。

* 最小構成ではレプリカは1台のみ


## 処理フロー

### マスター

#### マスター:初期化

* `datastore::ready`の呼び出しまでは、通常のシーケンスで起動。
* `datastore::ready`の処理
  * 環境変数などを経由して最小構成の設定パラメータを読み、通常(レプリケーションなし)で起動するのか、レプリケーションのマスタとして起動するのか決定する。
  * レプリカにに接続し、コントロールチャネルを作成する。
    * 失敗したらAbortする。
  * ローカルのログチャネルと同じ数だけ、レプリカログチャネルを作成する。
    * 一つでも失敗したら、Abortする。
    * log_channelに、レプリカログチャネルに関する情報を保持可能にする。
      * 保持するのは、ソケットディスクリプタを含む、レプリカログチャネルを含むオブジェクト
    * `std::vector<std::unique_ptr<log_channel>> datastore::log_channels_`の全要素に対してレプリカログチャネルを作成し、セットする。

#### マスター：ログ書き込み

ここでは、各log_channelにおける、begin_session～end_sessionの処理について述べる。

* `log_channel::begin_sesssion`
  * ローカルストレージへの書き込み後に、レプリカログチャネルに`begin_session`のエントリを書き込む
* `log_channel::add_entry`
  * add_entry以外の以下の呼び出しも同様に処理する
    * remove_entry
    * add_storage
    * remove_storage
    * truncate_storage
  * ローカルストレージへのエントリ書き込み後、レプリカログチャネルにエントリを書き込む
  * BLOBエントリでは、BLOBファイルもエントリに書き込む
* `log_channel::end_session`
  * ローカルストレージへのfsyncと並行して、レプリカログチャネルに`end_sesion`のエントリを書き込む。
  * ローカルストレージのfsyncが終了し、かつ`end_session`のACKが返るまでブロックする。
  * この処理でスレッドをたてる必要はなく、fsync前に`end_session`のエントリを返し、fsync完了後に、Ackを待つのでもよい。
    * レプリカログチャネルへの`end_session`書き込みがブロックすることを考えると別スレッドの方が良いが、ちょっとだけ面倒

#### マスター:グループコミット

現状のLimestoneは、グループコミットが完了の条件が整うと、次のコールバックを
順次呼び出す。

* write_epoch_callback
  * エポックファイルの更新を行うコールバック
* persitent_callback
  * shirakamiに永続化完了を通知するコールバック

レプリケーションの最小構成では、write_epoc_callbackの中で、
epochファイルの更新と共に、レプリカにグループコミットの通知を行う。
epochファイルの更新とグループコミットのAck受信が、両方とも
終了したら、コールバックを終了する。

その後、persitent_callbackが呼ばれ、`SOTRED`と、`PROPAGATED`が
両方満たされたときに、persitent_callbackが呼ばれる。

**Note**

エポックファイルの更新と、レプリカのグループコミットの順序が未検討

* エポックファイルの更新 => レプリカへのグループコミット指示 => Ack受信
* レプリカへのグループコミット指示 => Ack受信 => エポックファイルの更新
* レプリカへのグループコミット指示 => エポックファイルの更新　=> Ack受信 


### レプリカ


#### レプリカ:初期化

* mainメソッドの処理
  * datastoreの初期化 => インスタンスの作成まで
    * 初期化のために、ログディレクトリの情報が必要 
  * ソケットをリッスンする。
  * ソケットをアクセプトする。
    * 最初にアクセプトとするのは、レプリカ・コントロールチャネル
      * 先に、レプリカ・ログチャネルの要求が来たらAbort
      * レプリカ・コントロールチャネル作成後、レプリカ・コントロールチャネルの要求が来たらAbort
    * レプリカ・ログチャネルをアクセプトしたら、`datastore::create_channel`でローカルのログチャネルを呼び出す。
    * アクセプトしたら、当該チャネル用のスレッドを割り当て、当該チャネルの処理はそのスレッドが受け持つ
  * ログチャネルの作成が終了したら、`datastore::ready`を呼び出し、datastoreの初期化を終了する。


**Note**

* 既定の数のログチャネル作成が完了したという情報をどのように入手するのか
* `datastore::ready`を呼ぶ前に、レプリカ・コントールチャネルや、レプリカ・ログチャネルを通して到着したメッセージをどう処理するのか。
  * メッセージにより処理する・エラーにするのを分ける。
  *  `datastore::ready`を呼ぶまで、当該ソケットをreadしないので考慮不要 => レプリカ・ログチャネルはこれで良さそう。


#### レプリカ：ログ書き込み

* レプリカは、レプリカ・ログチャネルから受け取ったエントリを、そのままローカルのログチャネルに書き出す。
  * 基本的に受信したエントリに合致するlog_channelのメソッドを呼び出す。
  * 対応するエントリ
    * begin_sesion
    * add_entry
    * remove_entry
    * add_storage
    * remove_storage
    * truncate_storage
    * end_session(ログの書き込みは行わずfsyncするのみ)
  * end_sessionに対してはAckを返す。それ以外は、Ackを返さない。

#### レプリカ：グループコミット

* マスタからグループコミットのメッセージを受信したら、switch_epochを呼び出す。
* グループコミット完了の条件が整うと、write_epoch_callbackが呼ばれるので、そこでEpochの書き込みを行い、その後にグループコミットメッセージに対するACKが返信可能になったことを通知する。


## persistent_callback

LimestoneからShirkamaiへの永続化の通知は、既存のI/Fをそのまま使用する。既存では以下のどちらかの条件が満たされたときに、`persistent_callback`が呼ばれる。ただし複数のEpochがほぼ同時に条件を満たした場合は、古いEpochに対する通知が省略されることがある。

1. 特定のEpochのローカルストレージへの永続化が完了したとき(`STORED`)。
2. 特定のEpochで永続化が行われないことが確定したとき。 

レプリケーションの最小構成では、1.の通知をローカルストレージへの永続化完了(`STORED`)と、レプリカへの伝搬が完了したとき(`PROPAGATED`)に変更する。


## レプリケーションとローカルへの永続化の並列性

ここでは、レプリケーションとローカルへの永続化をどこまで非同期に行うかを議論する。

### 前提事項

* 既存のDatastoreのI/Fは変更しない。すなわち、以下のI/Fを維持し後述のように修正する。

1. `log_channel`を通してWALを書き込む
2. 同一の`log_channel`インスタンスのメソッドが同時に呼ばれることはない
3. `log_channel::begin_session`で特定Epochのセッションを開始し、`log_channel::end_session`で、セッションを終了しローカルディスクの永続化を行う。
4. `log_channel::begin_session`と、`log_channel_end_session`のあいだに`log_channel::#log_channel::add_entry`などのメソッドを使用してWALを書き込む。
5. `data_store::switch_epoch`でエポックの切り替えを行う。エポックの切り替えと、`log_channel`によるWALの永続化は非同期に行われる。また、異なる`log_channel`間では呼び出しは同期されず任意のタイミングで呼び出される。
6. `data_store::switch_epoch`でエポックの切り替えが起きた後、最新のEpochより古いEpochで、すべてのセッションが終了していいて、かつ当該セッションより、古いすべてのEpochのセッションが終了しているときに、永続化が完了したとみなし、`persistent_callback`を呼び出す。

* 一つの`log_channel`は、一つのレプリカに対して、1本のソケットを使用しつづける。これによりメッセージの追い越しがないことが補償される。
* 最小億世では、障害等により、ソケットのセッションが切れることを想定しない。したがって、再接続の方法などについても、議論しない。


### レプリカへのメッセージ送信とAckの受信について

#### `log_cahnnel::begin_sesion`および`log_channel::add_entry`等

* 同一スレッドで、ローカルディスクへの書き込み、レプリカへの送信を順次行う
  * データが大きくない限り、どちらもOSのバッファへの書き込みであり、短時間に終了することが良そうされうｒ。
  * ローカルディスクへの書き込みはバッファキャッシュへの書き込み、レプリカへの送信はソケットバッファへの書き込みであり、前者の方が圧倒的にサイズが大きく長時間ブロックされる可能性が低いので、先に実行する。
  * 別スレッドで並列で書き込む案もある。
    * 書き込みサイズが小さい場合、スレッドの生成/Wakeupなどのコストが高く並列化してもさほど効果がないと考えられる(ただし、結論は測定してだすべき)
    * 最小構成では実装量を減らしたい。
* Ackの返信はまたない。
  * Ackの返信を待つと、性能へのペナルティが大きい。
  * Ackは誰が受信するかという問題がのこる。最小構成では、このケースでAckを送信しないというのが良さそう。
* `TCP_NODELAY`を無効にしてソケットに書き込み、小さなパケットが大量に送信されるのを抑制する。

#### `log_channel::end_session`

* 現実装では、`log_channel::end_session`ローカルディスクへの書き込みは行わず、当該ログチャネルのファイルストリームに対して、fsyncを実行する。
* 最小構成では、これに加えてレプリカに対して、`end_session`のメッセージを送信し、Ackを待つ。
  * `end_session`は`TCP_NODELAY`を有効にして送信し、レプリカにすぐにメッセージが届くようにする。
  * レプリカは、当該セッションのすべての書き込みが完了し、さらにfsyncを実行、fsync完了後にAckを変える。
  * `begin_sesion`および`add_entry`等のメッセージは、同一のソケットで、`end_session`に先だって送信されるので、レプリカは、`end_session`時に同一セッションのすべてのメッセージを受信済みであることが補償される。
* 上記二つの操作は別スレッドで並列に行う。

* レプリカは、`log_channel::end_session`では、fsyncの実行後に完了を待たずにackを返し、エポックの切り替え時までfsyncの完了を待つという案もある。
  * こちらの方が、性能面で有利に思えるが、大きな差はないとも思える。
  * 現状のlimestoneのローカルストレージへの永続化が、`log_channel::end_session`でfsyncを行っているのでそれに合わせるなら、この方法は不採用。
  * そもそも、こちらの方が実装が複雑なので、最小構成では不採用。



## その他の機能

最小構成では、その他の機能に対して次のように対応する。

* コンパクション
  * マスターのコンパクションはレプリカに伝搬しない
  * レプリカ単独でのコンパクションは可能
    * オンライン、オフラインともに動作可能    
* BLOBファイルのGC
  * 起動時のGCは動作する。
  * コンパクション時のGCは動作しない
    * 動作しないようにするための作りこみが必要
  * 別案1: GC境界をマスタからレプリカに伝搬させて、オンライン魂魄所持にGCする。
  * 別案2: オフラインコンパクションを禁止する(機能をとめるか、できるけでやってはいけない扱いにするのか)
* レプリカに終了機能を用意しない。
  * 必要なら、CTRL+Cで停止する。
  * マスタは、レプリカとのソケットの接続が切断されたことを検知したらAbortする。
* セーフスナップショット切り替え
  * 実装しない(現行のlimestoneに実装がない)


## 設定パラメータ

### マスター

* TSURUGI_REPLICATION_ENDPOINT
  * `tcp://<host>:<port>`
  * レプリカのIPアドレスと、ポート番号


### レプリカ

* TSURUGI_REPLICATION_ENDPOINT
  * `tcp://<host>:<port>`
  * ポート番号のみ参照する。
* ログディレクトリのパス


## チューニングパラメータ

ここでは、最小構成用に追加するパラメータについて記述する。既存パラメータについては言及しない。
パラメータファイル等で変更可能にすることを想定しているが、定数で保持するだけかあもしれない。

* ソケットバッファのサイズ


## 課題など

* エントリの通知の方法
  * Add entry呼び出し毎
    * 埋金の想定
  * log_cahnnel::endsession呼び出し時にまとめて
    * メッセージフォーマットは、これを想定していいそう
  * その他

* 初期化時に、すべてのログチャネルの作成が終了したことを、レプリカがどうやってしるのか
* グループコミット時の、Epochファイルの更新と、レプリカのグループコミットの処理順をどうすべきか
* BLOBファイルのGCに関連して、オンラインコンパクションとGC境界の移動をどのように扱うのか





## 方針メモ

* 最初の実装では、プロトコル定義を完全に満たす実装は目指さない
  * プロトコル定義されていても動作しないメッセージがあることを意味する。
  * 最小構成の動作に必要な通信のみを、プロトコル定義に従って実装する
  