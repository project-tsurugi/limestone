# レプリケーションの最小構成のメモ

[レプリケーションの最小構成のドキュメント](https://nautilus-technologies.app.box.com/file/1794091239958)
を読んだときのメモです。

## コンセプト

> * ホットスタンバイ
>   *  -> マスターの切り替えには、最低でもデータベースの起動時間程度を要する

ということは、マスターの切り替えは実現するということ

あとはOK



## デザイン方針

> * マスターは、WAL 書き込みやエポック切り替えの信号を、レプリカにも送信する

* エポックの切り替え、かなり高頻度なのだが、すべてレプリカの送信する必要があるのか。
* すべて送信が必要として、その理由は。
* 当該エポックでWALの書き込みがなかった場合、スキップしたほうがよくないか。

> * グループコミットの開始等の信号は、上記とは独立した接続 (レプリカ・コントロールチャネル) で行う

* セッションの開始、WAL出力、セッションの終了、switc_epoch以外の何かがあると理解、それはなにか？
  
> WAL の書き込みは、ログチャネルと同じ数だけレプリカと接続 (レプリカ・ログチャネル) を用意し、接続ごとにデータ転送を行う

* レプリカ・コントールチャネルと、レプリカ・ログチャネルの同期は、必要ないのか。必要な場合、どうやって同期するのか。

> * グループコミットのタイミング制御はマスター側で行う

* これ何だろう 


## アーキテクチャ

OK

## 処理の流れ

### 処理の流れ：初期化

* **セッションID**とは何だろう

### 処理の流れ：ログ書き込み

> *レプリカは、マスターに対してログチャネル経由で ACK を返す

ACKを返すのは、WALへの追記が行われた(Qまたは行うこと保証できる状態になった)タイミング
であり、その時点でsyncは行わている保証はないという理解 => 後ろにsyncに関する記述が
あったのでこれでOK

> * マスターは、トランザクションエンジンに対し WAL エントリの書き込み完了を通知する

log_channel::add_entry()の終了が、書き込み完了の通知と考えてよいのか。

> マスターは、レプリカ・ログチャネルに対して、ログエントリの書き出しを指示する (プロトコル：ログエントリ書き出し)

この処理の返し前に、log_channelに対する操作が行われない保証が必要。一連の操作が
終わるまで。log_channel::end_session()が終了せず、またlog_channel::end_session()
呼び出し中は、log_channelに対する操作が行われないことから保証できるのだと理解。

呼び出し側が、そのように動作するのかは不明だが、多分問題ない。

log_channel::begin_session, log_channel::end_session
に関する記述がないが、詳細設計で検討が必要。

明記されていないが、add_entry以外のremove_entryなども書き込みの対象と理解。
begin_session , end_sessionも対象か？



### 処理の流れ：グループコミット

> マスターは、直前のエポックに関する WAL エントリの書き出しを待ち合わせる

マスターは、直前のエポックに関する WAL エントリの書き出しが終了する(log_channel::end_sessionが呼ばれる)のをまつという意味だろうか


## プロトコル

### プロトコル：セッション開始

このセッション開始は、log_channel::begin_session()とは
別ものだと理解、名前を変えないと混乱する。

> * チャネル
>    * 新規 TCP 接続



protocol_version は、通信プロトコルのことで、今回version 1
という理解でよいか。

configuration_id　これは、セットアップ時に設定ファイルで
定義するなどして指定する、サーバを示すIDという理解で良いか。

epoch_numberは、セッション開始時点で最後にswitch_epochで通知された
エポックIDという理解で良いか。

* 最大ログチャネル数
=> Limestoneは、最大ログチャネル数という概念をもたず、いくらでも
ログチャネルをつくれるが、どう実装すべきか。
   * datastore::create_channelを呼べば、読んだ数だけlog_channelを作成する。

* 作成可能なログチャネル数を制限する(指定可能にする)
* レプリケーションのセッション開始時に、すでに存在するログチャネルの数？
* そもそも、このパラメータ不要かも。
  

### プロトコル：セッション終了

OK

### プロトコル：グループコミット

OK

### プロトコル：セーフスナップショット切り替え

OK

### プロトコル：GC境界切り替え

### プロトコル：ログチャネル開始

これは、log_channel::begin_session()ではなく、datastore::create_channel()のことだと理解

### プロトコル：ログチャネル終了

これは、何のために必要なのか。現行のlimestoneには、datastore::create_channel()
はあるが、datastore::delete_channel()はない。


### プロトコル：ログエントリ送付

ここでいうエポックは、次のどちらなのか(後者と理解)
* switch epochで通知されたepoch
* Wal Entryに含まれるEpoch

### プロトコル：ログエントリ書き出し

## 構成
### 構成：マスター
### 構成：レプリカ

## その他
### 並列化可能部分

### 埋金の疑問点

* コンパクションの扱い
* コンパクション、バックアップに伴うPWALのローテーションの扱い
* コンパクション操作まで同期する必要があるのか
* コンパクションしないと、復元に時間がかかる。
* 最初の実装の対象外でよいか

* TCPセションが切れたときのリカバリに言及がない。

* 直近の実装では、Limestoneプラス、レプリケーションプロセスの構成で、Limestone以外のモジュールは変更しないという理解

* persistent_callback_
  * 現行のpersistent_callback_をどう修正するのか。
    * STORED, PROPAGETEDの区別がない。
    * 永続化が行われない場合でもpersistent_callback_呼んでいる。
* 全部終わったら、STORED
