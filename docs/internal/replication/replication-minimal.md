# レプリケーションの最小構成

## この文書について

## コンセプト

* 最小限の構成で、コミットに成功したトランザクションログをほかのマシン上に複製して記録する
  * マスターのログ・ストレージへの操作 (エポック切り替え、ログの書き込み、等) を複製し、レプリカ上で同様の操作を行う
  * マスターとレプリカとの同期ポイントを多めに取り、個々のスパンの性能検証を行いやすくする
* 以下については、このフェーズでは行わない
  * フェイルオーバー
    * -> マスターは手動で選択し、マスター、クライアントのいずれかがダウンするとシステムもダウンする
  * ホットスタンバイ
    * -> マスターの切り替えには、最低でもデータベースの起動時間程度を要する
  * 起動時のレプリカとの同期
    * -> 起動時にマスターとレプリカは同一のスナップショットを有する必要があり、そうでない場合には起動に失敗する
  * 例外ハンドリング
    * -> 将来的に作りこむが、本フェーズではエラーが発生した場合にはシステムもダウンする
  * 認証・暗号化
    * -> マスターとレプリカは、お互いを信頼している前提をおく
  * 性能
    * -> 個別機能の性能検証を行いやすくするため、一部の性能を犠牲にして物理境界を明確にする

## デザイン方針

* "性能評価しやすいこと" を優先する
  * 状態数を最小限に抑え、各状態の性能特性を計測しやすくする
  * 並列化可能な部分もオプションによって直列化できるようにする
* マスターとレプリカで、ファイル構成が同一であることを **要求しない**
  * メッセージの追い越し等を考慮し、マスターとレプリカでログファイルの内容等が完全に一致する必要はない
  * ただし、書き込んだファイルからデータベースをリストアできる必要があるため、ファイルフォーマットは同一とする
* レプリケーション構成専用にハードコーディングする
  * 機能の組み込みを簡単にするため、 Limestone にレプリケーション機能をハードコーディングし、その状態ではスタンドアロン構成 (従来構成) で稼働できなくなってもよい
  * 将来的には、設定ファイルでスタンドアロンまたはレプリケーション構成を切り替え可能にする
* マスターは、WAL 書き込みやエポック切り替えの信号を、レプリカにも送信する
  * グループコミットの開始等の信号は、上記とは独立した接続 (レプリカ・コントロールチャネル) で行う
  * WAL の書き込みは、ログチャネルと同じ数だけレプリカと接続 (レプリカ・ログチャネル) を用意し、接続ごとにデータ転送を行う
  * BLOB データの書き込みは、ログチャネルとは別の接続 (レプリカ・BLOBチャネル) を用意し、データ転送を行う
    * ただし、初版ではなくてもよい
* Tsurugi から独立した「レプリカサービス」を導入する
  * マスターからの WAL や制御情報を受け取る、独立したレプリカサービスプロセスをまず導入する
  * 前述のコントロールチャネル・ログチャネルを介して、マスターからWALや制御情報を受け取ってローカルストレージへの書き込み等を行う
  * 性能検証を行ったうえで、最終的にレプリカサービスプロセスを Limestone 内に組み込んでいく
* グループコミットのタイミング制御はマスター側で行う
  * レプリカサービス上での計算を簡素にするため、マスターでグループコミット完了のタイミグを計算し、それをレプリカに通知する
* 簡素化のため、BLOB データはレプリカ・ログチャネル上で送信する
  * 将来的には、別チャネルに分けたほうが全体の性能は向上するが、初版ではこのようにする
* 死活監視は行わない
  * 基本的にマスターからレプリカへの request-response 形式なので、遅くとも次のリクエストまでには検出できる

## アーキテクチャ

TBD:図

* レプリケーションセッション
  * 各種チャネルを束ねる仮想的なセッション
* レプリカ・コントロールチャネル
  * レプリケーションセッション自体の操作や、グループコミットの指示等を、レプリカに通知するチャネル
* レプリカ・ログチャネル
  * WALエントリをレプリカに送付するチャネル
  * 今フェーズでは BLOB データもこのチャネル上で送信する

## 処理の流れ

### 処理の流れ：初期化

1. マスターは、データベースの起動シーケンスにおいて、レプリケーションセッションを開始する ([プロトコル：セッション開始](#プロトコルセッション開始))
2. レプリカは、レプリケーションセッション開始の要求を受け取ったら、マスターの持つスナップショットとレプリカの持つスナップショットを比較し、互換性がない場合にはエラーを返す
3. レプリカは、セッションシークレット (ランダムな識別子) を発行し、マスターに返す
4. マスターは、セッションを開始した TCP ソケットをコントロールチャネルとして以後取り扱う
5. マスターは、ローカルのログチャネルの分だけレプリカ・ログチャネルを開始する ([プロトコル：ログチャネル開始](#プロトコルログチャネル開始)) (レプリカ側省略)
6. マスターは、以上でレプリケーション関連の初期化を完了し、残りのその他の初期化処理を行う

### 処理の流れ：ログ書き込み

1. トランザクションエンジンは、マスターのログチャネルに対して WAL エントリを書き込む (`log_channel::add_entry`)
2. マスターは、ログチャネルの内部で、ローカルの WAL ファイルに WAL エントリを追記する
3. マスターは、レプリカ・ログチャネルに対して、WAL エントリを送信する ([プロトコル：ログエントリ送付](#プロトコルログエントリ送付))
   * このとき、 WAL エントリに BLOB 参照が含まれる場合、その BLOB データもレプリカに送信する
   * また、ログエントリを随時レプリカに送信するのではなく、ログチャネルのセッション終了までにまとめて送付してもよい
4. レプリカは、レプリカ・ログチャネルから受け取った WAL エントリをローカルの WAL ファイルに追記する
   * このとき、BLOB エントリがあれば BLOB ストアに BLOB ファイルを作成する
5. レプリカは、マスターに対してログチャネル経由で ACK を返す
6. マスターは、トランザクションエンジンに対し WAL エントリの書き込み完了を通知する
7. トランザクションエンジンは、マスターのログチャネルについて、当該トランザクションに対する WAL 書き込みを終了する (`log_channel::end_session`)
8. マスターは、ログチャネルの内部で、ローカルの WAL ファイルを fsync する
9. マスターは、レプリカ・ログチャネルに対して、ログエントリの書き出しを指示する ([プロトコル：ログエントリ書き出し](#プロトコルログエントリ書き出し))
10. レプリカは、レプリカ・ログチャネルからの指示を受けて WAL ファイルを fsync する
11. レプリカは、マスターに対してログチャネル経由で ACK を返す
12. マスターは、トランザクションエンジンに対し、WAL 書き込みの成功を通知する

### 処理の流れ：グループコミット

1. トランザクションエンジンは、マスターに対してエポックの切り替えを通知する
2. マスターは、直前のエポックに関する WAL エントリの書き出しを待ち合わせる
3. マスターは、直前のエポックの WAL エントリをすべて書きだし終わったのを確認し、ローカルのエポックファイルに対して当該エポック番号を書きだす
4. マスターは、トランザクションエンジンに対し、直前のエポックに関するローカル永続化 (`STORED`) を通知する
   * この情報は最終的にクライアントまで届けられる
5. マスターは、レプリカ・コントロールチャネルに対して、グループコミットの指示を送信する ([プロトコル：グループコミット](#プロトコルグループコミット))
6. レプリカは、コントロールチャネル経由でグループコミットの支持を受け取り、ローカルのエポックファイルに対して当該エポック番号を書きだす
7. レプリカは、マスターに対してコントロールチャネル経由で ACK を返す
8. マスターは、トランザクションエンジンに対し、直前のエポックに関するリモート永続化 (`PROPAGATED`) を通知する
   * この情報は最終的にクライアントまで届けられる

## プロトコル

プロトコルは仮に Protocol BUffers 形式で表記する。
具体的な表現は、詳細設計時に決定する。

すべてのメッセージは、マスターからレプリカに対して 1-request : 1-response で行う。

### プロトコル：セッション開始

* 概要
  * マスターの初期化プロセスにおいて、レプリケーションセッションを開始する
* チャネル
  * 新規 TCP 接続
* エラー例
  * プロトコルバージョンが一致しない
  * レプリケーションが空でない状態において、構成IDが一致しない
  * グループコミット位置が一致しない

```protobuf
message request.SessionBegin {
    // レプリケーション自体のプロトコルバージョン
    int64 protocol_version = 1;

    // 前回と同一のマスターであることを識別するためのID
    string configuration_id = 2;

    // グループコミット位置
    uint64 epoch_number = 3;

    // 最大 ログチャネル数
    uint64 log_channel_count = 4;
}
```

```protobuf
message response.SessionBegin {

    // 成功時のメッセージ
    message Success {
        // シークレット
        string secret = 1;
    }

    oneof result {
        Success success = 1;
        Error error = 2;
    }
}
```

### プロトコル：セッション終了

* 概要
  * レプリケーションセッションを終了する
* チャネル
  * コントロールチャネル
* エラー例
  * セッションが開始していない

```protobuf
message request.SessionEnd {}
```

```protobuf
message response.SessionEnd {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

### プロトコル：グループコミット

* 概要
  * 指定のエポックでグループコミットを行う
* チャネル
  * コントロールチャネル
* エラー例
  * セッションが開始していない
  * エポック番号が不正 (巻き戻りの発生等)
* 備考
  * このメッセージに ACK が返ってきたら、レプリカ上での当該グループコミットを成功とする
  * エポック番号は厳密に単調増加するが、番号を飛ばす場合がある
  * 指定されたエポック番号未満で、グループコミットされていないログエントリが存在する場合、それらも永続化の対象とする (エラーとしない)

```protobuf
message request.GroupCommit {

    // グループコミット対象エポック
    uint64 epoch_number = 1;
}
```

```protobuf
message response.GroupCommit {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

### プロトコル：セーフスナップショット切り替え

TBD (このフェーズでは発行しない)

### プロトコル：GC境界切り替え

* 概要
  * 指定のバージョンで GC 境界を設定する
* チャネル
  * コントロールチャネル
* エラー例
  * セッションが開始していない
  * ライトバージョンが不正 (巻き戻りの発生等)

```protobuf
message request.GcBoundarySwitch {

    // GC境界となるライトバージョン
    uint128 write_version = 1;
}
```

```protobuf
message response.GcBoundarySwitch {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

### プロトコル：ログチャネル開始

* 概要
  * マスターの初期化プロセスにおいて、レプリカ・ログチャネルを作成する
* チャネル
  * 新規 TCP 接続
* エラー例
  * シークレットが現在のセッションに合致しない
  * ログチャネル数が上限に達している

```protobuf
message request.LogChannelCreate {

    // シークレット
    string secret = 1;
}
```

```protobuf
message response.LogChannelCreate {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

### プロトコル：ログチャネル終了

* 概要
  * ログチャネルを破棄する
* チャネル
  * ログチャネル
* エラー例
  * ログチャネルが作成されていない

```protobuf
message request.LogChannelDispose {}
```

```protobuf
message response.LogChannelDispose {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

### プロトコル：ログエントリ送付

* 概要
  * レプリカにログエントリを送付する
* チャネル
  * ログチャネル
* エラー例
  * ログチャネルが作成されていない
  * 指定したエポックはグループコミット完了済み
  * 指定したエポック番号が単調増加でない
  * レプリカ側で書き込みに失敗した
* 備考
  * BLOB データを合わせて送付するため、 Protocol Buffers での転送は適切ではない
  * TBD: BLOB の転送最適化のため、以下のようなことを実験の上検討する
    * BLOB チャネルを別途作成し、仮登録段階で本体データを登録する
  * 実際のディスクへの書き込みは [プロトコル：ログエントリ書き出し](#プロトコルログエントリ書き出し) まで遅延させてもよい

```protobuf
message request.LogEntryWrite {

    // 対象のエポック番号
    uint64 epoch_number = 1;

    // 書き込むエントリの一覧
    repeated LogEntry entry_list = 2; 

    // ログチャネル内でのセッションを開始するかどうか
    bool session_begin = 3;

    // ログチャネル内でのセッションを終了するかどうか
    bool session_end = 4;

    // 書き込み完了後にディスクにフラッシュするかどうか
    bool flush = 5;
}
```

```protobuf
message LogEntry {

    // エントリの種類
    EntryType operation = 1;

    // Write バージョン
    uint128 write_version = 2;

    // 対象のストレージID
    uint64 storage_id = 2;

    // キー
    bytes key = 3;

    // バリュー
    bytes value = 4;

    // BLOB データ
    repeated BlobEntry = 5;

    // エントリの種類
    enum EntryType {

        UNSPECIFIED = 0;

        // エントリ追加
        PUT = 1;

        // エントリ削除
        DELETE = 2;

        // ストレージ削除
        DELETE_STORAGE = 3;
    }
}
```

```protobuf
message BlobEntry {
  
    // BLOB ID
    uint64 blob_id = 1;

    // BLOB データ
    bytes data = 2;
}
```

```protobuf
message response.LogEntryWrite {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

### プロトコル：ログエントリ書き出し

* 概要
  * レプリカにこのチャネルから送付したログエントリを書き出す
* チャネル
  * ログチャネル
* エラー例
  * ログチャネルが作成されていない
  * レプリカ側で書き込みに失敗した

```protobuf
message request.LogChannelFlush {}
```

```protobuf
message response.LogChannelFlush {
    oneof result {
        Ack success = 1;
        Error error = 2;
    }
}
```

## 構成

### 構成：マスター

* プロセス
  * `tsurugidb` プロセス内の、 limestone コンポーネントの一部として構成
* レプリカ・コントロールチャネル
  * `datastore::ready()` 内部で開始 ([プロトコル：セッション開始](#プロトコルセッション開始))
    * 接続先は `TSURUGI_REPLICATION_ENDPOINT` に `tcp://<host>:<port>` を指定する
  * エポックファイルの更新のタイミングで、 [プロトコル：グループコミット](#プロトコルグループコミット) を送信する
* レプリカ・ログチャネル
  * `log_channel` 作成時にスタブを作成し、 `datastore::ready()` の内部で開始 ([プロトコル：ログチャネル開始](#プロトコルログチャネル開始))
    * 接続先はコントロールチャネルと同様に、 `TSURUGI_REPLICATION_ENDPOINT` に指定
  * `log_channel::begin_session` 実行時に [プロトコル：ログエントリ送付](#プロトコルログエントリ送付) の `begin_session` フラグを立てて送信する
    * または、初回の `log_channel::add_entry` まで遅延させてもよい
  * `log_channel::add_entry` 実行時に、 [プロトコル：ログエントリ送付](#プロトコルログエントリ送付) を送信する
    * または、バッファして `log_channel::end_session()` のタイミングでまとめて送信してもよい
  * `log_channel::begin_session` 実行時に [プロトコル：ログエントリ送付](#プロトコルログエントリ送付) の `end_session` と `flush` フラグを立てて送信する
    * `flush` を立てる代わりに、 [プロトコル：ログエントリ書き出し](#プロトコルログエントリ書き出し) を送信してもよく、 `flush` の操作はバッファして [プロトコル：グループコミット](#プロトコルグループコミット) のタイミングまで遅延してもよい

### 構成：レプリカ

* プロセス
  * 新規プロセスとして実行 (`tsurugidb-replication-service` など)
  * マスターよりも先に起動しておく必要がある
  * プロセス終了方法については定義しない
* レプリケーション・セッション
  * 特定の TCP ポートで listen (`TSURUGI_REPLICATION_ENDPOINT` の定義と対応付ける)
* レプリカ・コントロールチャネル
  * 初期化
    * TCP セッションに対し、最初のメッセージが [プロトコル：セッション開始](#プロトコルセッション開始) であれば、コントロールチャネルとして初期化する
    * ランダムなシークレットを生成して返す
    * ただし、現在のプロセスにおいてすでにセッションが開始している場合には、エラーを返す
  * サービス
    * [プロトコル：グループコミット](#プロトコルグループコミット)
      * エポックファイルを更新する
    * [プロトコル：セーフスナップショット切り替え](#プロトコルセーフスナップショット切り替え)
      * セーフスナップショットの位置を切り替える (現在未使用:LOG-2以降に利用)
    * [プロトコル:GC境界切り替え](#プロトコルgc境界切り替え)
      * ログエントリのGC境界を切り替え、必要であればコンパクション操作を行う
    * [プロトコル：セッション終了](#プロトコルセッション終了)
      * 現在のレプリケーションセッションを終了する
* レプリカ・ログチャネル
  * 初期化
    * TCP セッションに対し、最初のメッセージが [プロトコル：ログチャネル開始](#プロトコルログチャネル開始) であれば、ログチャネルとして初期化する
    * 特定のログファイルと関連付け、必要であればファイルを書き込みモードで開いておく
    * レプリケーションセッション開始時のシークレットと一致しない場合は失敗させる
  * サービス
    * [プロトコル：ログエントリ送付](#プロトコルログエントリ送付)
      * ログエントリをローカルの WAL ファイルに書き込む
      * `begin_session` フラグが立っている場合、ログエントリの書き込み前にログセッションの開始を書き込む
      * `end_session` フラグが立っている場合、ログエントリの書き込み後にログセッションの終了を書き込む (現在は空)
      * `flush` フラグが立っている場合、操作の末尾にファイルポインタをフラッシュ (fsync) する
    * [プロトコル：ログエントリ書き出し](#プロトコルログエントリ書き出し)
      * ローカルの WAL ファイルのファイルポインタをフラッシュ (fsync) する
    * [プロトコル：ログチャネル終了](#プロトコルログチャネル終了)
      * ログチャネルを終了する

## その他

### 並列化可能部分

* 基本方針
  * 全体的に、ローカル -> リモート の順に直列に書いているが、それぞれ async I/O を利用することで並列化可能であると考えている
  * また、現状はマスター・レプリカが 1:1 の構成を想定しているが、 1:N になった際には、それぞれのレプリケーションセッションに対して並列に書き込みを行うことで性能を稼げると考える
* 並列化対象候補
  * ローカルディスクへの WAL エントリの追記と、 [プロトコル：ログエントリ送付](#プロトコルログエントリ送付) の部分
  * ローカルディスクの WAL ファイルの fsync と、[プロトコル：ログエントリ書き出し](#プロトコルログエントリ書き出し) の部分
  * ローカルディスクのエポックファイルへの書き込みと、[プロトコル：グループコミット](#プロトコルグループコミット) の部分
    * ただし、仕様上 `STORED` が `PROPAGATED` より前に変えることを想定していないため、通知の順番だけは調整が必要
