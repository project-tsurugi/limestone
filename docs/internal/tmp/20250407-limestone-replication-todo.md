# limestone レプリケーション機能の残件
 

## 設計書との乖離

### レプリケーション機能の実装方針

* グループコミット時のレプリカの動作
  * 仕様では、switch_epochを呼ぶようになっているが、これは仕様バグなので、Epoch更新処理を呼ぶように実装。
* TCP_NODELYの使用方法
  * セッション中にTCP_NODELAYの指定を切り替えることを想定していたが、これは意図したように動作する保証がないことがわかったので、常時TCP_NODEALYを指定するようにした。
    * 小さい単位で、socketに書き込んだ時に必要以上にパケットが飛ぶのを抑制するために自前のバッファを使用

### レプリケーションの最小構成

#### コンセプト

> * 起動時のレプリカとの同期
>    * -> 起動時にマスターとレプリカは同一のスナップショットを有する必要があり、そうでない場合には起動に失敗する

同一のスナップショットを要するかのチェックが未実装。

> * マスターとレプリカで、ファイル構成が同一であることを **要求しない**

* ちゃんと確認はしていないが、ファイル構成は同一になっているはず。
* データの追い越しが起きる経路がないはず。

> * レプリケーション構成専用にハードコーディングする
 
環境変数有無で、レプリケーションモードと、スタンドアロンモードが切り替わる。

> * マスターは、WAL 書き込みやエポック切り替えの信号を、レプリカにも送信する

エポック切り替えの信号に関する信号が3種類ある

* group_commit
* safe-snapshot
* gc boundary

この中でレプリカに送信するのはgroup_commitの信号のみ。

>   * BLOB データの書き込みは、ログチャネルとは別の接続 (レプリカ・BLOBチャネル) を用意し、データ転送を行う

現状はログチャネルでの転送を行っている

> * Tsurugi から独立した「レプリカサービス」を導入する

レプリカサービスを実現するためのtgreplicaコマンドを作成


#### 処理の流れ：初期化

> 2. レプリカは、レプリケーションセッション開始の要求を受け取ったら、マスターの持つスナップショットとレプリカの持つスナップショットを比較し、互換性がない場合にはエラーを返す
> 3. レプリカは、セッションシークレット (ランダムな識別子) を発行し、マスターに返す

これは未実装。


### 処理の流れ：グループコミット


> 1. トランザクションエンジンは、マスターに対してエポックの切り替えを通知する
> 2. マスターは、直前のエポックに関する WAL エントリの書き出しを待ち合わせる
> 3. マスターは、直前のエポックの WAL エントリをすべて書きだし終わったのを確認し、ローカルのエポックファイルに対して当該エポック番号を書きだす
> 4. マスターは、トランザクションエンジンに対し、直前のエポックに関するローカル永続化 (`STORED`) を通知する
>    * この情報は最終的にクライアントまで届けられる
> 5. マスターは、レプリカ・コントロールチャネルに対して、グループコミットの指示を送信する ([プロトコル：グループコミット](#プロトコルグループコミット))
> 6. レプリカは、コントロールチャネル経由でグループコミットの支持を受け取り、ローカルのエポックファイルに対して当該エポック番号を書きだす
> 7. レプリカは、マスターに対してコントロールチャネル経由で ACK を返す
> 8. マスターは、トランザクションエンジンに対し、直前のエポックに関するリモート永続化 (`PROPAGATED`) を通知する
>    * この情報は最終的にクライアントまで届けられる

* 現状、4, 8は未実装。そもそも、永続化の通知I/FがSTORED/PROPAGATEDを通知できるようになっていない。
* 8.のタイイングで、persistent_callbackを呼び出すだけ。


### レプリケーション最小構成の通信プロトコル

#### 共通データ構造

* 仕様書

```c
struct string {
    u32 size;
    u8[size] data;
}
```

* 実装 => バイトとビットの間違い

```c
struct string {
    u4 size;
    u1[size] data;
}
```

#### ログエントリのデータ構造

* 仕様書
  
```c
struct log_entry {
    u1 operation_type;
    u16 write_version;
    u8 storage_id;
    string key;
    string value;
    u6 blob_list_size;
    blob_entry[blob_list_size] blob_list;
}
```
* 実装: blob_list_sizeをu4に変更

```c
struct log_entry {
    u1 operation_type;
    u16 write_version;
    u8 storage_id;
    string key;
    string value;
    u4 blob_list_size;
    blob_entry[blob_list_size] blob_list;
}
```


### TCP ソケットのステート


| ステート名 | 説明 |
|:--|:--|
| `CONNECTED` | TCP ソケットに接続した状態 |
| `DISCONNECTED` | TCP ソケットを切断した状態 |
| `CONTROL` | コントロールチャネルとして初期化された状態 |
| `LOG` | ログチャネルとして初期化された状態 |


このステートマシンは、実装していない。




#### 未実装のプロトコル

* プロトコル：レプリケーションセッション終了
* プロトコル：セーフスナップショット切り替え
* プロトコル：GC境界切り替え
* ログチャネル破棄
* プロトコル：ログチャネル書き出し
  * ログエントリ送付の`LOG_OPERATION_FLUSH`で代替


## 効率改善系

* `log_channel::begin_session`, `log_channel::end_session`を単独のメッセージとして送信しているが、add_entryのメッセージに載せて、送受信するメッセージを減らしたい。
* バッファリングの効率化
  * バッファリングしないで、socketのread/writeをすると、非効率なのでバッファリングをしているが、実装を簡単にする方に倒したので、効率面で最適でないかも。
* ローカルストレージへの書き込みと、レプリケーション処理のヘリ列化
  * 現状は逐次処理している



## ソースコードのTODOより

### 本体

* 未実装系
  * ログチャネル、コントロールチェネルのセッション作成時の認証がまったく行われていない。
    * なくても動くので、作っていない。
  * プロトコル上32bitだが、言語仕様的にそれ以上の長さになりえる値(例: std::vector::size(), key/valueのvalueのサイズ)に
     対するオーバーフローのチェックをしていない。
* 通信エラー時のエラー処理が不足
  * 現状、次のいずれかだが、必ずしも適切に処理できていない
    * LOGに書いて何もしない
    * LOGに書いて異常終了
    * LOGに書いて例外をスローする。
* バリデーションエラー時のエラーコードに適当な値とメッセージを入れている。
  * TCPセッション確立時のバリデーションのこと
  * 仕様を決めて、仕様に合わせて実装し、仕様ともどもメンテナンスすべき
  * 現状は、そもそもバリデーション機能自体を適当につくっている。


* リファクタリング系
  * socket_ioクラスの整理
    * 現状 socket_io -> blob_socket_io という構成になっている。
      * 先にblob以外を作って、後付でblob対応したらこうなった
      * テスト用のコードがsokcet_ioクラスに入っているので分けたい。
      * TCP以外を称することも想定舌方がより。
    * 次のような構造にしたい
      * replication_io
        * socket_io
        * testable_io
        * other_io
  * dynamic castを使わないようにする
    * 上記socket_ioクラスもそうだが、dynamic castを使わなくても実現可能なコードでdynamic castを使っている部分がある。
  * プロトコルバージョンが、メッセージの基底クラスのconstになっているが、専用のヘッダファイルに移したい。

### テスト

* 開発時に追加した機能により、通らなくなったテストでDISABLED_にしたままのテストがある。
  * log_channel_begin_session
    * end_ssssion時にACKを待つようにした結果テストが通らない、大幅にテストを修正しないといけない。
    * 別のテストで、該当機能はテストされているので、DISABLED_にしておいてめあまり問題ない。
* 毎度のことだが、エラー処理のUTが不足している。
  * 例
    * setsock_optが失敗した時のテスト
    * ソケットに対するread/writeがEINTRや、EBADFで中断したときのテスト
  * 本来であれば、システムコールの呼び出しを Mock と差し替え可能にし、ユニットテストではその Mock 
    を使ってエラーケースを再現すべきだが、現状ではそのような構造にはなっていない。
* テストに使うhelper関数について
  * 共通化可能なテスト用のヘルパー関数を共通化する。



## Other

* ログ全般が適当なので、以下の観点で整理改善が必要
  * 必要なログがでていないか
  * 無駄にログをだしているか
  * ログレベルは適切化
* 死活監視
* タイムアウト
* keepalive
  * set_sockoptでSO_KEEPALIVEをつけるもしていない。

* replicaコマンドが、プロダクションで使えるUIにする。  
  * tgctlに組み込む？
  * 専用コマンドにする。

## 週報より

* エラー処理系
* シャットダウン機能
* ドキュメントの整理
    * ドキュメントと実装が違う部分
    * 未実装項目
* Masterへのマージ
* 性能測定
