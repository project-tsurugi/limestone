# get_partitioned_cursors(n) 設計メモ

## 概要

インデクスす生成の高速化のため、snapshotクラスに複数カーソルを返すメソッド
`get_partitioned_cursorsを追加し、マルチスレッド処理を可能にする。

最初は、最小の工数で動作する実装を作ることを優先する。


## 用語定義

| 用語 | 意味 |
|------|------|
| **Primary Cursor** | `get_cursor()` により返されるカーソル。スナップショット全体を逐次走査する。実体は `cursor_impl`。現行のcursorの実装である。 |
| **Partitioned Cursor** | `get_partitioned_cursors(n)` により返されるカーソル群。それぞれ disjoint な領域を担当。実体は `partitioned_cursor_impl`。 これから実装する。|
| **Primary Cursor Thread** | `get_partitioned_cursors()` を呼び出すスレッド（カーソル生成時に使用される）。 |
| **Cursor Worker Thread** | 各 partitioned cursor を処理するスレッド。1つのカーソルにつき1スレッドが独占的に使用する。 |


## 関数仕様

### シグネチャ

```cpp
std::vector<std::unique_ptr<cursor>> snapshot::get_partitioned_cursors(std::size_t n);
```

### パラメータ

```
引数 | 型 | 説明
-----|----|-----
n    | std::size_t | 最大でいくつのパーティションに分割するか（1以上）。
```

### 返り値

```
std::vector<std::unique_ptr<cursor>>

要素数は 1〜n。たとえスナップショットにデータが存在しなくても、空カーソル1個を返す。
```

### 例外

```
種類 | 条件
------|-----
std::invalid_argument | n == 0 の場合
limestone_exception   | この関数が snapshot インスタンス上で2回以上呼び出された場合
limestone_exception または limestone_io_exception | カーソル生成中に致命的なエラーが発生した場合（I/Oエラー、破損など）
```

### 制約事項

- snapshot インスタンスごとにこの関数は1回のみ呼び出せる。
- カーソルはすべて非スレッドセーフ。
- Partitioned Cursor を複数スレッドで共有してはならない。
- 返される Partitioned Cursor 群の担当領域は互いに重複しない。
- パーティションの戦略（範囲、順序、粒度）は実装依存。
- 戻り値に含まれる各 cursor は null ではなく有効である。
- 各 Partitioned Cursor の受信キューにはサイズ制限がなく、フロー制御（バックプレッシャ）は行われない。

### 備考

- Partitioned Cursor は snapshot の寿命に依存しない設計となっているが、将来の変更に備え、使用者は snapshot を保持することが推奨される。
- 現時点では、snapshot が破棄された後も Partitioned Cursor の操作は機能する可能性があるが、これは保証されない。

## 実装方針

### 方針概要

全スナップショットを1スレッドで走査（Primary Cursor Thread）し、エントリを複数のキューに **ラウンドロビン**で分配する方式を採用する。各 Partitioned Cursor は自身のキューに対して順にアクセスする。

### 分割戦略

- Partitioned Cursor の個数 `n` に対して、Primary Cursor は snapshot 全体を順次読み取り、
  **固定サイズのバッチ単位**でエントリを n 個のキューに分配する。
- 分配方式は単純なラウンドロビン（例：カーソル 0 → 1 → 2 → ... → n-1 → 0 → ...）であり、
  データ量やキー値には依存しない。

## get_partitioned_cursors() の処理概要

1. **Primary Cursor Thread の生成と起動**
    - スナップショット全体を走査してエントリを分配する専用スレッド（Primary Cursor Thread）を生成・起動する。
    - このスレッドはバックグラウンドで実行され、各 Partitioned Cursor のキューに対してデータを供給する。


2. **Partitioned Cursor の生成**
    - 指定された個数 `n` に応じて、各 Partitioned Cursor が参照する専用キューを生成する。
    - それぞれのキューを参照する `partitioned_cursor_impl` インスタンスを構築し、`cursor` インターフェースでラップして返す。


返却されるカーソルは、各 Partitioned Cursor に対応する `cursor` オブジェクトであり、複数のスレッドで独立に使用されることを前提とする。


### Primary Cursor Thread の処理概要

Primary Cursor Thread は、スナップショット全体を走査しながら、各 Partitioned Cursor に対応するキューへエントリを分配するバックグラウンドスレッドである。

このスレッドは `get_partitioned_cursors()` 呼び出し時に生成・起動されるが、呼び出し元スレッド（Primary Cursor Thread を生成したスレッド）は、このスレッドの終了を待たずに Partitioned Cursor 群を返す。

#### 主な処理内容

1. **Primary Cursor の生成**
    - `cursor_impl` を使用して、スナップショット全体を走査可能な Primary Cursor を作成する。

2. **エントリの走査と分配**
    - `next()` を使ってエントリを順次取得する。
    - あらかじめ定義されたバッチサイズ（例：`constexpr std::size_t k_batch_size = 100`）ごとにエントリをまとめ、
      現在のターゲットキューに一括で投入する。
    - キューの選択はラウンドロビンにより順番に決定される。

3. **終了通知の送信**
    - Primary Cursor の走査中に以下のいずれかが発生した場合、各 Partitioned Cursor のキューに「終了マーカー」を送信する：
      - **正常にすべてのエントリを走査し終えた場合**
      - **例外（たとえばファイル破損や I/O エラーなど）により走査が中断された場合**
    - この終了マーカーには、終了理由（正常終了／異常終了）を示す情報が含まれる。
    - Partitioned Cursor 側はこのマーカーを検知し、必要に応じて例外を再スローするか、安全に `next() == false` を返す。

4. **スレッドの終了**
    - 処理完了後、Primary Cursor Thread は正常または異常に関わらず終了する。
    - `get_partitioned_cursors()` 呼び出し側はこのスレッドの終了を待たないため、明示的な同期（例：join）は行わない。

#### 備考

- 各 Partitioned Cursor は、終了マーカーの内容を読み取り、呼び出し元の `next()` などで例外再スローを行うかを

### Partitioned Cursor の処理概要

各 Partitioned Cursor は、自身に割り当てられた専用キューからスキャン対象のエントリを順次取得する。データ供給はバックグラウンドで動作する Primary Cursor Thread により行われる。

Partitioned Cursor の主な外部インターフェースは `cursor` として提供される `next()`, `key()`, `value()` である。

#### `next()`

- 内部キューから次のエントリまたは終了マーカーを取得する。
- 正常なエントリが取得できた場合は、その内容を内部状態に保存し `true` を返す。
- 終了マーカーが取得された場合は、正常終了か異常終了かに応じて以下の動作を行う：
  - 正常終了：内部状態をリセットし、以降は常に `false` を返す。
  - 異常終了：`limestone_exception` など適切な例外を送出する。
- キューが空の場合は、データが供給されるまでブロックする。

#### `key(std::string& buf)`

- `next()` で取得したエントリの key を `buf` に書き込む。
- `next()` が直前に呼び出されていない、または `false` を返した後に呼び出された場合の動作は未定義（設計に応じて assert もしくは no-op にする）。

#### `value(std::string& buf)`

- `next()` で取得したエントリの value を `buf` に書き込む。
- `key()` と同様、事前に `next()` が成功している必要がある。

#### その他の動作仕様

- `storage()` や `type()` など他の API も同様に、内部状態に保持された現在のエントリに対して動作する。
- 内部状態が存在しない（`next()` が呼ばれていないか、終了後）の場合は未定義動作とする。


## Queueについて

### 要件の整理

1. **スレッドモデル：SPSC (Single-Producer Single-Consumer)**
   - 各キューには **1つの生産者スレッド（Primary Cursor Thread）** と **1つの消費者スレッド（Partitioned Cursor）** のみがアクセスする。

2. **データ構造：FIFO を原則とする**
   - 現時点の実装では順序保証は必須ではないが、**将来的に順序（FIFO）を必要とする可能性が高いため、FIFO 構造を使用する。**

3. **フロー制御なし**
   - キューにはサイズ制限がなく、**push は常に成功することを前提とする（バックプレッシャなし）。**

4. **ブロッキング read**
   - キューが空のとき、**データが供給されるまで `next()` はブロックして待機する。**

5. **性能要件**
   - **現行の単一カーソル実装よりも性能が向上することが前提である。**
   - ただし、**より高性能な実装が存在しても、簡易な実装で十分な性能が得られるならばそちらを優先する。**

### 使用するキューライブラリ候補

#### 第1候補：`boost::lockfree::spsc_queue`

- **長所**
  - 高性能（ロックフリー）
  - `boost` が既にプロジェクトで使われている場合は依存関係の追加が不要
  - 単一生産者／単一消費者モデルに特化しているため適合度が高い

- **短所**
  - サイズが固定（初期化時に最大サイズを決める必要あり）
  - push に失敗する可能性がある（容量不足時）
  - ブロッキング read の仕組みがないため、自前で `condition_variable` 等による待機処理を追加する必要がある

- **対応方針**
  - **push 失敗時のワークアラウンドを導入予定**
    - put 前に空き容量を確認し、put できない場合はラウンドロビンの次のキューに送る
    - push に失敗する可能性を最小化するため、**十分なサイズで初期化**する
    - 将来的には適切なブロッキング機構も追加予定



#### 第2候補：`moodycamel::ReaderWriterQueue`（外部ライブラリ）

- **長所**
  - 非常に高性能なロックフリーキュー
  - SPSC に加え MPMC モードもサポート
  - コミュニティ実績がある

- **短所**
  - 外部依存（moodycamel のヘッダ追加が必要）
  - ブロッキング read を自前で実装する必要がある
  - FIFO 順を保証するが、スレッド間の細かな制御は必要

- **補足**
  - 長期的には有力な選択肢となるが、初期導入のハードルがやや高い

---

#### 第3候補：`folly::ProducerConsumerQueue`

- **長所**
  - Facebook Folly の一部として高性能かつ広く利用されている
  - ロックフリーで FIFO をサポート
  - 高度な最適化が施されている

- **短所**
  - `folly` という大型ライブラリへの依存が必要
  - 導入とビルド設定が複雑
  - ブロッキング read は自前実装が必要

- **補足**
  - 長期的に `folly` を使う予定がある場合は検討余地あり

---

#### 第4候補：`std::queue` + `mutex` + `condition_variable`

- **長所**
  - C++標準ライブラリのみで完結
  - カスタム実装しやすい（柔軟性が高い）

- **短所**
  - 排他制御と待機制御のコードを自前で実装する必要があり、**簡易とは言い難い**
  - ロックのオーバーヘッドにより性能が劣る可能性あり
  - 実装時の不備によるデッドロックなどのリスクがある

- **補足**
  - **初期プロトタイピング用途には向かない**可能性あり
  - 他の方式と比較して性能・安全性の点で慎重な実装が求められる

---

#### 結論

- まず**第1候補（`boost::lockfree::spsc_queue`）**を実装、評価する．