
# WAL同期バックアップ機能 設計書



## バックアップリクエスト


- バックアップセッション開始時にサーバへ送信するリクエスト。
- フィールド構成：
  - version (uint64): メッセージバージョン。将来の拡張や互換性維持のために使用。
  - begin_epoch (uint64): バックアップの開始エポック番号（この値を含む）。0指定で全期間対象。
  - end_epoch (uint64): バックアップの終了エポック番号（この値は含まない）。0指定で現時点まで。
- begin_epoch と end_epoch でバックアップ範囲を柔軟に指定可能。
- 両方0の場合は全データのフルバックアップ。



## バックアップ対象

* PWALファイルとEpochファイル
  * バックアップリクエスト受付時にPWALファイルとEpochファイルのローテーションを行う。ローテーション後に更新されたファイルは当該リクエストの対象外。
  * 過去にローテーションされたPWALファイルもバックアップ対象となる。
  * backup_object_typeはLOGおよびMETADATA。
* コンパクション済みファイル
  * 最新のコンパクション済みファイルおよびコンパクションカタログがバックアップ対象。
  * バックアップ中はコンパクションが行われないよう排他制御を行う。
  * backup_object_typeはSNAPSHOT。

* その他のメタデータ
  * wal_history: WAL履歴
  * limestone-manifest.json: マニフェストファイル
  * compaction_catalog: コンパクションカタログ
  * backup_object_typeはMETADATA。
* BLOBファイル
  * backup_object_typeはBLOB。



## バックアップリクエスト


### ローテーション

* バックアップリクエスト受付時、PWALファイルとEpochファイルをローテーションし、ローテーション済みファイルをバックアップ対象とする（現行方式と同様）。


## begin_epochとend_epoch



### フルバックアップ

* begin_epoch, end_epochともに0の場合、フルバックアップとみなす。現行のフルバックアップと同等のファイルがコピー対象：
  * ローテーション済みPWAL（コンパクション済みPWALは除く）
  * 最新のローテーション済みEpoch
  * limestone-manifest.json
  * compaction_catalog
  * wal_history
  * BLOBファイル（BLOBディレクトリ内でバックアップリクエスト時に生成されたものを除く全BLOB。next_blob_idで判定）


### 差分バックアップ


* begin_epoch, end_epochのいずれかが0でない場合、差分バックアップとみなす。
* end_epoch < begin_epochの場合はエラー。
* リモートバックアップサービス側でコンパクションが行われていた場合、最後のコンパクション済みファイルに含まれる最大Epochより大きい値のみbegin_epochに指定可能（同値不可）。
  * コンパクションカタログに記載されたWALファイルはバックアップ対象外。
* end_epoch ≠ 0の場合、epochファイルはバックアップ対象外。クライアント側で指定Epochのエポックファイルを作成する（将来的に不要となる可能性あり）。
* 現状のPWALファイルは最初のエントリで最小Epochが分かるが、最大Epochは全走査が必要。
  * 最小Epochのみを基準に、バックアップ対象epochを含む可能性のあるPWALファイルは全てバックアップ対象。
  * このため、実際にWALエントリを含まないPWALファイルも対象となる場合がある（EOFマーカー導入で改善予定）。



### 差分バックアップ時のBLOBの扱い


1. PWALファイルのコピー後にBLOBファイルのコピーを行う。
2. PWALコピー時、BLOBを含むログエントリのBLOB_IDを読み取りリスト化（同一ID複数回出現あり）。
  * リストが巨大化する可能性はあるが、初期実装ではメモリ上で処理。
3. 2で生成したリストのうち、実在するBLOBファイルのみを差分バックアップ対象とする。
* BLOBリクエストのレスポンスにはBLOBファイルを含めない。
* WALコピー要求時、当該WALが含むBLOBファイルもコピーする。



### BLOBファイルのGC


* GCによりBLOBファイルが削除されている可能性がある場合、差分バックアップは失敗とする。
  * end_epochが起動時のdurable_epoch以下の場合、GCにより指定epochのBLOBファイルが削除されている可能性あり。
  * オンラインコンパクション時、コンパクション済みファイルに含まれる最大epoch未満のend_epochが指定されている場合も同様。
    * この場合、BLOBだけでなくWALエントリ自体が削除されている可能性があるため、BLOBに限らず失敗とする。




#### バックアップ対象BLOBの選択方法


BLOBファイルは直接Epochと紐付かないため、バックアップ対象BLOBの選択方法が課題となる。
* 案1: クライアント・リモートバックアップサービス双方で保持BLOBリストを取得し、差分をコピー
* 案2: PWALコピー時にBLOBエントリを読み取り、必要なBLOBリストを生成してコピー

レプリケーション時、マスタ/レプリカのどちらかのみコミット成功した場合に不完全なBLOBファイルが残ることがある。
* リモートバックアップサービス側ではこれをコピー対象としない必要があり、案1ではBLOBファイルGCが必要。
* クライアント側でも不完全BLOBが存在しうるため、バックアップ復旧時に対応が必要。案1では差分バックアップ前にGCを行い削除する。
* 案1はサービス・クライアント双方でBLOBファイルGCが必要だが、案2に対する大きなメリットがないため案1を採用。



## バックアップ対象の保護


* バックアップセッション有効中は、当該セッションのバックアップ対象ファイルを変更・削除不可とする。
* アクティブなバックアップセッションを管理し、存在時はコンパクション処理を停止。
  * コンパクション要求はキューイングし、セッション終了まで実行しない。
* ローテーション処理は排他制御し、同時実行を防止。開始時にロック取得、完了まで他要求を待機させることで整合性を確保。






## EOFマーカー


### EOFマーカー導入の目的


バックアップ対象のPWALファイルを特定するには、PWALファイルが保持するEpochの最小値・最大値が必要となる。現状のPWALフォーマット（Version6）では、最大値を特定するためにファイル全体を走査し、最後のmarker_beginを見つける必要がある。

この課題を解決し、他用途にも拡張可能とするためEOFマーカーを導入する。


### EOFマーカーのフォーマット


* log_entryの一種として実装（marker_begin, marker_end, normal_entry, remove_entry等と同列）。
* 名称はmarker_eof。
* 末尾8バイトに以下を格納：
  * EOFマーカー（marker_eof）のサイズ（4バイト）
  * マジックナンバー（'MEOF'固定、4バイト）
* その他のフィールド：
  * entry_type: 他のエントリタイプと同様
  * version: EOFマーカーのバージョン
    * 1: 現行バージョン
  * 当該PWALファイルが保持するEpochの最大値
* log_entryの一種として実装する。
    * marker_begin, marker_end, normal_entry, remove_entry...といったエントリと同列。
    * marker_eofという名称にする。


### EOFマーカーの付与

* EOFマーカーはPWALファイルのローテーション時、ローテーション済みファイルの末尾に追加される。
* バックアップ・コンパクション要求に伴うローテーション時：
  * log_channelは最後に書き込んだEpochを保持し、ローテーション要求時にその値を末尾に追加。
  * ファイル書き込みとローテーションは別スレッドで行われるため、整合性確保のため、EOFマーカー追記タスクをキューイングし、全タスク終了後にローテーション完了とする。
  * タスクは該当epochの処理終了を確認後、EOFマーカーを追記（処理中はブロック）。
  * 現行の実装はこの仕組みがないので、ローテーション後に書かれたデータが、バックアップやコンパクションの対象にならなない可能性がある。これはバグ。

### ローテーション済みPWALファイルの破損と復旧

* ローテーションによるPWALファイルのリネームからEOFマーカー追加処理完了までの間に障害が発生した場合、ローテーション済みPWALファイルが破損状態となることがある。主な状態と復旧方法は以下の通り。

* ファイルの最後のEpochのmarker_endが存在しない。
  * 破損したPWALファイルとみなす。
  * 最後のEpochのepoch idがdurable epoch以下の場合は修復不能。
  * durable epochより大きい場合は修復可能。リペア後は「ファイルの最後のEpochが存在するが、EOFマーカーが存在しない」ケースと同様に扱う。
* ファイルの最後のEpochが存在するが、EOFマーカが存在しない。
  * 案1: 旧フォーマットのPWALファイルとみなす（EOFマーカー必須処理では全体走査で代替）
  * 案2: 破損ファイルとみなし、リペアコマンドでEOFマーカーを追加

* 起動時、およびrepairコマンドによる診断、修復の両方で対応が必要。

* 初期実装は案1、案2への切り替えは別タスクとする。
* 旧ファイルフォーマットではEOFマーカーが存在しないが、同様に扱う。

## その他


### EpochファイルのローテーションとEpochの更新のスレッドセーフ性

現行のEpochファイルのローテーション処理はスレッドセーフでなく、Epochの更新とローテーションが同時に行われると破損の可能性がある（同期コードが存在しない）。
ただし、rename・openシステムコールはどちらもatomicに実行されるため、基本的に問題は発生しにくい。


### コンパクション済みWALファイルの扱い

* コンパクション時、コンパクション済みWALファイルは削除されず「削除可能」と記録されるのみ。
* 差分バックアップ用途でPWALファイルを残す設計だが、本設計では使用しないため、コンパクション時に削除してもよい。
* フルバックアップの対象とすべきかは要検討（本設計では対象外、現行フルバックアップでは対象）。


### ローテーション済みPWALファイルの破損

ローテーション直後にプロセスダウンやOSクラッシュ等が発生した場合、ローテーション済みPWALファイルが破損する可能性がある。
現状のコードは、ローテーション済みPWALファイルが破損していないことを前提にしている箇所があるかもしれない。
