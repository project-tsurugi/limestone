
# WAL同期バックアップ機能 設計書



## バックアップリクエスト


- バックアップセッション開始時にサーバへ送信するリクエスト。
- フィールド構成：
  - version (uint64): メッセージバージョン。将来の拡張や互換性維持のために使用。
  - begin_epoch (uint64): バックアップの開始エポック番号（この値を含む）。0指定で全期間対象。
  - end_epoch (uint64): バックアップの終了エポック番号（この値は含まない）。0指定で現時点まで。
- begin_epoch と end_epoch でバックアップ範囲を柔軟に指定可能。
- 両方0の場合は全データのフルバックアップ。



## バックアップ対象

* PWALファイルとEpochファイル
  * バックアップリクエスト受付時にPWALファイルとEpochファイルのローテーションを行う。ローテーション後に更新されたファイルは当該リクエストの対象外。
  * 過去にローテーションされたPWALファイルもバックアップ対象となる。
  * backup_object_typeはLOGおよびMETADATA。
* コンパクション済みファイル
  * 最新のコンパクション済みファイルおよびコンパクションカタログがバックアップ対象。
  * バックアップ中はコンパクションが行われないよう排他制御を行う。
  * backup_object_typeはSNAPSHOT。

* その他のメタデータ
  * wal_history: WAL履歴
  * limestone-manifest.json: マニフェストファイル
  * compaction_catalog: コンパクションカタログ
  * backup_object_typeはMETADATA。
* BLOBファイル
  * backup_object_typeはBLOB。



## バックアップリクエスト


### ローテーション

* バックアップリクエスト受付時、PWALファイルとEpochファイルをローテーションし、ローテーション済みファイルをバックアップ対象とする（現行方式と同様）。


## begin_epochとend_epoch



### フルバックアップ

* begin_epoch, end_epochともに0の場合、フルバックアップとみなす。現行のフルバックアップと同等のファイルがコピー対象：
  * ローテーション済みPWAL（コンパクション済みPWALは除く）
  * 最新のローテーション済みEpoch
  * limestone-manifest.json
  * compaction_catalog
  * wal_history
  * BLOBファイル（BLOBディレクトリ内でバックアップリクエスト時に生成されたものを除く全BLOB。next_blob_idで判定）


### 差分バックアップ


* begin_epoch, end_epochのいずれかが0でない場合、差分バックアップとみなす。
* end_epoch < begin_epochの場合はエラー。
* リモートバックアップサービス側でコンパクションが行われていた場合、最後のコンパクション済みファイルに含まれる最大Epochより大きい値のみbegin_epochに指定可能（同値不可）。
  * コンパクションカタログに記載されたWALファイルはバックアップ対象外。
* end_epoch ≠ 0の場合、epochファイルはバックアップ対象外。クライアント側で指定Epochのエポックファイルを作成する（将来的に不要となる可能性あり）。
* 現状のPWALファイルは最初のエントリで最小Epochが分かるが、最大Epochは全走査が必要。
  * 最小Epochのみを基準に、バックアップ対象epochを含む可能性のあるPWALファイルは全てバックアップ対象。
  * このため、実際にWALエントリを含まないPWALファイルも対象となる場合がある（EOFマーカー導入で改善予定）。



### 差分バックアップ時のBLOBの扱い


1. PWALファイルのコピー後にBLOBファイルのコピーを行う。
2. PWALコピー時、BLOBを含むログエントリのBLOB_IDを読み取りリスト化（同一ID複数回出現あり）。
  * リストが巨大化する可能性はあるが、初期実装ではメモリ上で処理。
3. 2で生成したリストのうち、実在するBLOBファイルのみを差分バックアップ対象とする。
* BLOBリクエストのレスポンスにはBLOBファイルを含めない。
* WALコピー要求時、当該WALが含むBLOBファイルもコピーする。



### BLOBファイルのGC


* GCによりBLOBファイルが削除されている可能性がある場合、差分バックアップは失敗とする。
  * end_epochが起動時のdurable_epoch以下の場合、GCにより指定epochのBLOBファイルが削除されている可能性あり。
  * オンラインコンパクション時、コンパクション済みファイルに含まれる最大epoch未満のend_epochが指定されている場合も同様。
    * この場合、BLOBだけでなくWALエントリ自体が削除されている可能性があるため、BLOBに限らず失敗とする。




#### バックアップ対象BLOBの選択方法


BLOBファイルは直接Epochと紐付かないため、バックアップ対象BLOBの選択方法が課題となる。
* 案1: クライアント・リモートバックアップサービス双方で保持BLOBリストを取得し、差分をコピー
* 案2: PWALコピー時にBLOBエントリを読み取り、必要なBLOBリストを生成してコピー

レプリケーション時、マスタ/レプリカのどちらかのみコミット成功した場合に不完全なBLOBファイルが残ることがある。
* リモートバックアップサービス側ではこれをコピー対象としない必要があり、案1ではBLOBファイルGCが必要。
* クライアント側でも不完全BLOBが存在しうるため、バックアップ復旧時に対応が必要。案1では差分バックアップ前にGCを行い削除する。
* 案1はサービス・クライアント双方でBLOBファイルGCが必要だが、案2に対する大きなメリットがないため案1を採用。



## バックアップ対象の保護


* バックアップセッション有効中は、当該セッションのバックアップ対象ファイルを変更・削除不可とする。
* アクティブなバックアップセッションを管理し、存在時はコンパクション処理を停止。
  * コンパクション要求はキューイングし、セッション終了まで実行しない。
* ローテーション処理は排他制御し、同時実行を防止。開始時にロック取得、完了まで他要求を待機させることで整合性を確保。








### EpochファイルのローテーションとEpochの更新のスレッドセーフ性

現行のEpochファイルのローテーション処理はスレッドセーフでなく、Epochの更新とローテーションが同時に行われると破損の可能性がある（同期コードが存在しない）。
ただし、rename・openシステムコールはどちらもatomicに実行されるため、基本的に問題は発生しにくい。


### コンパクション済みWALファイルの扱い

* コンパクション時、コンパクション済みWALファイルは削除されず「削除可能」と記録されるのみ。
* 差分バックアップ用途でPWALファイルを残す設計だが、本設計では使用しないため、コンパクション時に削除してもよい。
* フルバックアップの対象とすべきかは要検討（本設計では対象外、現行フルバックアップでは対象）。


### ローテーション済みPWALファイルの破損

ローテーション直後にプロセスダウンやOSクラッシュ等が発生した場合、ローテーション済みPWALファイルが破損する可能性がある。
現状のコードは、ローテーション済みPWALファイルが破損していないことを前提にしている箇所があるかもしれない。


