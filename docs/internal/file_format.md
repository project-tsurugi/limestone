# ファイルフォーマット

本ドキュメントでは、LimestoneLOG-0.5において、ログディレクトリに
どのようなファイルが置かれるのかと、LOG-0.6でどのような
変更が行われるかについて記述雨r。

ログディレクトリとは、`tsurugi.ini`の`datastore`のセクションで項目`log_location`
でしていするディレクトリ。


## ログディレクトリに書き込まれるファイル

LOG-0.5では以下のファイルがログディレクトリに保存される。

* マニフェストファイル
* PWALファイル
* エポックファイル
* スナップショットファイル

LOG-0.6では、LOG-0.5に加えて以下のファイルが保存される。

* コンパクション済みファイル
* コンパクションカタログファイル

この他に、テンポラリファイルなどが書き込まれる可能性があるが、
本セクションでは扱わない。


以降、各ファイルの詳細を記述する。

### マニフェストファイル

* ファイル名: cat limestone-manifest.json 
* ログディレクトリに1つだけ存在する。
* LOG-0.5でのファイルの内容
```
{
    "format_version": "1.0",
    "persistent_format_version": 1
}
```
* `format_version`がマニフェストファイルのフォーマットバージョン
* `persistent_format_version`がログディレクトリにあるファイルのバージョンをああわす
* LOG-0.6では、`persistent_format_version`は**2**になる。

### PWALファイル

* ファイル名は`pwal_数値4桁`の形式でデータディレクトリ直下に置かれる。
* ローテーションが行われると、ファイ名の末尾に時刻情報を付与したファイル名にリネームされる。
  * ローテーション後のWALファイルには原則としてデータは書き込まれない。例外として、ローテーション時にアクティブなログチャネルのセッションについては、当該セッションの終了までローテーション済みのファイルにWALデータを書き込む。

* WALファイルのエントリのタイプは次のように定義されている。

```
enum class entry_type : std::uint8_t {
    this_id_is_not_used = 0,
    normal_entry = 1,
    marker_begin = 2,
    marker_end = 3,
    marker_durable = 4,
    remove_entry = 5,
    marker_invalidated_begin = 6,
};
```
 * セッション開始時にWALファイルをオープンし、`entry_type::marker_begin`のエントリを書き込む
   * エントリには、エポックIDが含まれる。
   * このエポックIDは、セッション開始時にDatastoreが最新のエポックIDとして認識している値が入る。
 * セッション終了時に、ストリームをフラッシュ、Syncを実行後にクローズする。
   * LOG-0.5ではmarker_endを書き込んでいない。
* セッションがアクティブな間にエントリを追加するために2つのメソッドが用意されている。
  * 他にも多数のメソッドが用意されているが実装されていない。
  * `log_channel::remove_entry(storage_id_type storage_id, std::string_view key, write_version_type write_version)`
    * `entry_type::remove_entry`のエントリを書き込む。
    * エントリには、ストレージID、キー、バージョンが含まれる。
  * `log_channel::add_entry(storage_id_type storage_id, std::string_view key, std::string_view value, write_version_type write_version)`
    * `entry_type::normal_entry`のエントリを書き込む。
    * エントリには、ストレージID、キー、バリュー、バージョンが含まれる。

### エポックファイル

* エポックIDが書かれたバイナリファイル
* グループコミットの完了時にエポックIDを追記する。
* リストア時には、ここに書かれたエポックIDのデータまでをリストアする。
* ファイル名は、`epoch`
* ローテーションが行われると、ファイ名の末尾に時刻情報を付与したファイル名にリネームされる。

### スナップショットファイル

* 起動時に作成されるスナップショットファイル
* ファイル名は`snapshot`、ログディレクトリの下にdataというサブディレクトリが作成され、このディレクトリに作成される。
* 起動時のみに使用されるテンポラリファイルに準じたファイルだが、Tsurugiをシャットダウンした後も削除されずに残る。
* Tsurugi起動後、データが壊れているような障害発生時に調査に使用することがある。

### コンパクション済みファイル

* LOG-0.5ではファイル名`pwal_0000.compacted`で、PWALファイルとして扱われる。
* LOG-0.6以降ではファイル名を`cmpct_数値4桁`とし、PWALファイルとは別のファイルとして扱う


###　コンパクションカタログファイル

* ファイル名は`compaction_catalog`
* 以下の情報を記録する。
  * コンパクション済みファイルのファイル名とのセット
    * コンパクション済みファイルのセットの一部が欠損していないことの確認に使用する。
    * 何らかの理由で、コンパクション済みファイルのセットに含まれない、コンパクション済みファイルが存在する場合にそのファイルを処理対象外にするために使用する。
      * コンパクション処理中にクリティカルなタイミングで、Tsurugiが強制終了したようなケースを想定している。
  * コンパクション済みファイルのフォーマットバージョン
    * LOG-0.6では**1**
  * コンパクション済みファイルのセットに記録されているエポックのうち最大のエポックのエポックID
    * 起動時のスナップショット作成において、先頭のセッションのエポックIDがこのエポックIDより小さいPWALファイルは処理対象としない。
  * コンパクション済みのPWALファイルのセット
    * 上記の最大のエポックIDがあれば不要だがこれを記録しておくことにより、PWALファイルをオープンしてチェックする必要がなくなる。
    * ログディレクトリに存在しないファイルは記録対象外にする(そうしないと無限に増える)

## クラッシュ時のリカバリ

ログディレクトリのファイル操作中の特定のタイミングでTsurugiのプロセスが
クラッシュなどの原因で終了した場合(本セクションでは障害と記述)において、どおのような対策を行うのか
について記述する。

### マニフェストファイル

* ログディレクトリ初帰化時のマニフェストファイル作成中の障害
  * LOG-0.5以前
    * タイミングにより以下のいずれかの動作になる。
      * ログディレクトリが存在しない場合
        * 障害後の起動時に再度ログディレクトリの初期化が行われ問題なく動作する
      * ログディレクトリが存在するが、マニフェストファイルが存在しない場合
        * 障害後の起動時にマニフェストファイルが存在しないため、ログフォーマットがバージョン0と判断され、起動エラーとなる。
      * ログディレクトリが存在し、不完全なマニフェストファイルが存在する場合
        * 障害後の起動時にマニフェストファイルの破損が原因で起動に失敗する
      * 完全なマニフェストファイルが存在する場合
        * 通常通り起動する
  * LOG-0.6
    * LOG-0.5の動作を踏襲する
      * 起動に失敗するタイミングがごく稀でまず起きない
      * 起動に失敗した場合、ログディレクトリを削除後、再起動で復旧可能


* 起動時にマニフェストファイルのバージョンを1 -> 2に上げる操作中の障害
  * LOG-0.6で追加された処理
  * 以下の処理順で処理を行う
    * マニフェストファイルのファイル名を拡張子.backのついたファイル名にリネームする
    * 新しいマニフェストファイルを作成する 
  * 障害後の起動時の動作
    * LOG-0.6では最初のマニフェストファイルを読む操作の前に以下のロジックを追加する
    * 拡張子.backのマニフェストファイルが存在する場合
      * このファイルを正しいマニフェストファイルとして処理を続行する。
      * マニフェストファイルが存在する場合削除する
      * 拡張子.backのマニフェストファイルを拡張子のないマニフェストファイルにリネームする
      * その後、通常のシーケンスで起動する。
    * 拡張子.backのマニフェストファイルが存在しない場合
      * 通常のシーケンスで起動する。
　

### PWALファイル

* PWALファイル書き込み中の障害
  * LOG-0.5
    * エポックファイルと、PWALファイルの状況から以下のいずれかの動作をする。
      * PWALファイルの破損を検知し起動に失敗する
      * PWALファイルの破損を検知し修復したのちに起動する
      * PWALファイルは破損していなく通常通り起動する。
    * 起動に失敗した場合は、ログ修復ツールにより修復した後に起動する
  * LOG-0.6
    * LOG-0.5の動作を踏襲する
    * この部分はLOG-0.6のスコープ外

* ローテート中の障害
  * LOG-0.5ではローテーション中の障害に対応できていない
  * LOG-0.6の動作は、別資料(TODO: 資料への陸)で記述
   

* ローテート済みPWALファイルは、ローテーション中を除き変恋雨が行われないことが保証されているため、障害時のリカバリについて考慮不要


### エポックファイル

* LOG-0.5
  * 常にエポックIDを追記
  * 障害時には、最新のデュラブルエポックIDか、その一つ前のエポックIDどちらかが読めることが保証されている。
  * また、読み取れたエポックIDまでのデータがPWALファイルに保存されていることが保証されている。
* LOG-0.6
  * LOG-0.5の動作を踏襲する
  * 特に修正の必要がない


### スナップショットファイル

* 起動時に作成されるテンポラリファイルに準じたファイルのため、障害時の対策は不要


### コンパクション済みファイルとコンパクションカタログ

LOG-0.6では、コンパクション時の障害にそなえて以下のように動作する。

* コンパクション処理中は、前回のコンパクション処理の結果生成されたコンパクション済みファイルとコンパクションカタログを常に保持する。
* コンパクション処理の最後に、前回コンパクション時のファイルから今回コンパクションファイルの切り替えを行う。切り替え処理の詳細は後述する。
* 切り替え操作前の障害の動作
  * 障害後の起動時に、コンパクション処理によって作成中のファイルが存在する場合、それを削除する。
    * コンパクション処理中は、コンパクション済みファイルのファイル名に拡張子.tmpをつけたファイル名を用いる。
    * 拡張子.tmpがついたコンパクション済みファイルは起動時に削除する。
* 切り替え処理
  * コンパクションカタログを、.back付きのファイル名にリネーム
  * 新しいコンパクションカタログを作成する
  * 今回のコンパクション処理で作成したコンパクション済みファイルの拡張子.tmpを削除した名前にリネームする。
    * コンパクションカタログにはリネーム後のコンパクション済みファイルのファイル名を記述する。
  * .back付きのファイル名にリネームした古いコンパクションカタログを削除する
* 切り替え処理中の障害対応
  * 起動時に拡張子.backがついたコンパクションカタログの存在を確認し、存在する場合つぎのリカバリ処理を行う。
    * コンパクションカタログは最後にフッタを書き込むことにより、フッタの有無で完全/不完全を確認できるようにする。
    * 完全なコンパクションカタログが存在する場合は、コンパクションカタログに記録されたコンパクション済みファイルの有無をチェックし、存在する場合は削除する。
      * 削除しても問題ないように、コンパクション処理の前後で、コンパクション済みファイルのファイルセットでファイル名の衝突が起きないようにする。
      * リネーム前、リネーム後のどちらのコンパクション済みファイルも削除対象
    * 不完全なコンパクションカタログは削除する
    * 拡張子.backがついたコンパクションカタログを拡張子がないコンパクションカタログにリネームする。
    * これによりコンパクション処理がロールバックされる。
      * コンパクション時にローテーションされたファイルが残るがこれが問題ないようにコンパクション処理を行う。


## バックアップ対象ファイル

コンパクションの導入にともないバックアップファイルの選択対象となるファイルが変更になる。****


## datatoreの初期化時の動作

ログディレクトリが存在しないか空のときの初期化ロジックを変更する。

#### `datastore::datastore(configuration const& conf)`

既存メソッド`internal::setup_initial_logdir`の修正内容

* マニフェストファイルを作成 => log-0.6から persistent_format_version を2にする。

```
    nlohmann::json manifest_v1 = {
        { "format_version", "1.0" },
        { "persistent_format_version", 2 }
    };  
```    

TODO: Version2用のファイルの配置


### `datastore::recover()`

`datastore::datastore(configuration const& conf)`の次に呼ばれる。
現在引数違いの2メソッドがあるが、未実装、修正もない。


### `datastore::ready()`

* ログディレクトリの初期化以外の初期化はここで行われている。

```
void datastore::ready() {
    internal::check_logdir_format(location_);
    create_snapshot();
    state_ = state::ready;
}
```

#### `internal::check_logdir_format(location_);`

ここで、バージョン1であることを確認している。
バージョン0の場合はエラーにする。

これをバージョン1, 2の場合正常とし、
バージョン1のときバージョン2にマイグレードする

TODO: マイグレーションの実装


#### datastore::restore()

初期化ではないが、ここでもバージョンチェックが行われている
引数違いで2種類のメソッドがある。

初期化時と同じバージョンチェックのロジックを呼んでいたので、修正不要だった。
ただし以下のテストケースで、バージョンチェックでエラーになるテストを
しているが、バージョン2をしていしているためエラーにならない。
テストケースの修正が必要だった。

rotate_old_rejects_unsupported_data
rotate_prusik_rejects_unsupported_data


TODO: 差分バックアップの間にフォーマットバージョンアップがあったときの動作が未検証
  -> バックアップに失敗、リストアに失敗、リストア時に壊れる、問題ないなどのパターンが考えられる。
